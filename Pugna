--Pugna-- Script 3.2   by KillerZombie           [Test on Umbrella 8.6]
local Pugna = {}


Pugna.Menu = {"Hero Specific", "Pugna"}
Pugna.optionEnable = Menu.AddOptionBool({"Hero Specific", "Pugna"}, "Enable Pugna Combo", false)
Menu.AddMenuIcon({"Hero Specific", "Pugna"}, "panorama/images/heroes/icons/npc_dota_hero_pugna_png.vtex_c")
-- Hero Menu 1.0
Pugna.optionComboKey = Menu.AddKeyOption({ "Hero Specific", "Pugna" }, "Combo Key", Enum.ButtonCode.KEY_F)
Pugna.optionTargetStyle = Menu.AddOptionCombo({ "Hero Specific", "Pugna", "Targeting" }, "Targeting style ", {'locked target', 'free target'}, 1)
Pugna.optionTargetRange = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Targeting" }, "Target acquisition range",  200, 1000, 400)
Pugna.optionMoveToCursor = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting" }, "Move to Cursor Pos ", false)
Pugna.optionLockTargetIndicator = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting" }, "Draw target indicator ", false)
Pugna.optionLockTargetParticle = Menu.AddOptionCombo({ "Hero Specific", "Pugna", "Targeting" }, "Indicator style ", {'blinding light', 'blood bath', 'tower aggro'}, 1)
Pugna.optionTargetCheckAM = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting", "Target exclusions" }, "Exclude AM with agha ", false)
Pugna.optionTargetCheckLotus = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting", "Target exclusions" }, "Exclude active lotus orb ", false)
Pugna.optionTargetCheckBlademail = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting", "Target exclusions" }, "Exclude blademail ", false)
Pugna.optionTargetCheckNyx = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting", "Target exclusions" }, "Exclude spiked carapace ", false)
Pugna.optionTargetCheckUrsa = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting", "Target exclusions" }, "Exclude enraged ursa ", false)
Pugna.optionTargetCheckAbbadon = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting", "Target exclusions" }, "Exclude abaddon ult ", false)
Pugna.optionTargetCheckDazzle = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Targeting", "Target exclusions" }, "Exclude shallow grave ", false)
-- Items Castmenu
Pugna.optionItemEnable = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Offensive items" }, "Enabled", false)
Pugna.optionItemStyle = Menu.AddOptionCombo({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage" }, "Choose activation style", {'max speed, no order','ordered','smart ordered'}, 1)
Pugna.optionItemStack = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage" }, "Stack hex and silence", false)
Pugna.optionItemSoulring = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Soulring", false)
Pugna.optionItemVeil = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Veil Of Discord",  0, 18, 1)
Pugna.optionItemHex = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Scythe Of Vyse",  0, 18, 1)
Pugna.optionItemBlood = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Bloodthorn ",  0, 18, 1)
Pugna.optionItemeBlade = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Ethereal Blade",  0, 18, 1)
Pugna.optionItemOrchid = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Orchid Malevolence",  0, 18, 1)
Pugna.optionItemAtos = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Rod Of Atos",  0, 18, 1)
Pugna.optionItemAbyssal = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Abyssal Blade",  0, 18, 1)
Pugna.optionItemHalberd = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Heavens Halbert",  0, 18, 1)
Pugna.optionItemShivas = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Shivas Guard",  0, 18, 1)
Pugna.optionItemDagon = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Dagon",  -1, 18, 1)
Pugna.optionItemUrn = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Urn of shadows",  0, 18, 1)
Pugna.optionItemManta = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Manta Style",  0, 18, 1)
Pugna.optionItemMjollnir = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Mjollnir",  0, 18, 1)
Pugna.optionItemMedallion = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Medallion of Courage",  0, 18, 1)
Pugna.optionItemCrest = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Solar Crest",  0, 18, 1)
Pugna.optionItemSpirit = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Spirit Vessel",  0, 18, 1)
Pugna.optionItemNull = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Nullifier",  0, 18, 1)
Pugna.optionItemDiffusal = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Offensive items", "Combo usage", "Items" }, "Use Item Diffusal Blade",  0, 18, 1)
Pugna.optionDefensiveItems = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Enable auto usage ", false)
Pugna.optionDefensiveItemsGlimmer = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Glimmer Cape", false)
Pugna.optionDefensiveItemslotusOrb = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Lotus Orb", false)
Pugna.optionDefensiveItemsCrimson = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Crimson Guard", false)
Pugna.optionDefensiveItemsCrest = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Solar Crest", false)
Pugna.optionDefensiveItemsPipe = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Pipe", false)
Pugna.optionDefensiveItemsSatanic = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Satanic", false)
Pugna.optionDefensiveItemsThreshold = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "HP Threshold ", 10, 50, 5)
Pugna.optionDefensiveItemsThresholdDisable = Menu.AddOptionSlider({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "HP Threshold if disabled ", 35, 100, 5)
Pugna.optionDefensiveItemsMedallion = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, " Medallion of Courage", false)
Pugna.optionDefensiveItemsGhost = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Ghost scepter", false)
Pugna.optionDefensiveItemsAlly = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Cast defensive items on allies ", false)
Pugna.optionDefensiveItemsSaver = Menu.AddOptionBool({ "Hero Specific", "Pugna", "Items Cast", "Defensive Items" }, "Advanced lotus/glimmer ally saving ", false)
Pugna.optionHeroPugnaBlink =  Menu.AddOptionBool({ "Hero Specific", "Pugna"}, "Use blink in combo ", false)
Pugna.optionHeroPugnaBlinkRange = Menu.AddOptionSlider({ "Hero Specific", "Pugna" }, "Blink distance ", 100, 600, 50)
Pugna.optionHeroPugnaWard =  Menu.AddOptionBool({ "Hero Specific", "Pugna"}, "Use ward in combo", false)
Pugna.optionHeroPugnaWardCount = Menu.AddOptionSlider({ "Hero Specific", "Pugna"}, "Min. heroes in ward range", 1, 5, 1)
Pugna.optionHeroPugnaInvis =  Menu.AddOptionBool({ "Hero Specific", "Pugna"}, "Use GlimmerCape while life draining ", false)


	-- global Variables
local CurentHero = nil
Pugna.LockedTarget = nil
Pugna.myUnitName = nil
Pugna.lastCastTime = 0
Pugna.lastCastTime2 = 0
Pugna.lastCastTime3 = 0
Pugna.lastTick = 0
Pugna.delay = 0
Pugna.itemDelay = 0
Pugna.lastItemCast = 0
Pugna.lastDefItemPop = 0
Pugna.lastItemTick = 0
Pugna.ItemCastStop = false
Pugna.isArmletManuallyToggled = false
Pugna.isArmletManuallyToggledTime = 0
Pugna.armletDelayer = 0
Pugna.ControlledUnitCastTime = 0
Pugna.ControlledUnitPauseTime = 0
Pugna.lastAttackTime = 0
Pugna.lastAttackTime2 = 0
Pugna.LastTarget = nil
Pugna.LastTickManta1 = 0
Pugna.LastTickManta2 = 0

	-- global Tables
Pugna.LinkensBreakerItemOrder = {}
Pugna.ItemCastOrder = {}
Pugna.rotationTable = {}
Pugna.PuckOrbHitSim = {}
Pugna.enemyHeroTable = {}
Pugna.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
Pugna.PreInvokeSkills = {}
Pugna.preemptiveBKB = {}
Pugna.invokerCachedIcons = {}
Pugna.autododgerTable = {}
Pugna.autododgerReadyTable = {}
Pugna.autododgerSkillReady = {}
Pugna.wardDispenserCount = {}
Pugna.wardProcessingTable = {}
Pugna.lastHitCreepHPPrediction = {}
Pugna.lastHitCreepHPPredictionTime = {}
Pugna.creepAttackPointData = {}
Pugna.VisageFamiliarAttackCounter = {}
Pugna.heroIconHandler = {}
Pugna.itemIconHandler = {}
Pugna.ControllableEntityTable = {}
Pugna.ControllableAttackTiming = {}
Pugna.TinkerJungleFarmPos = {}
Pugna.JungleTrackTable = {}
Pugna.ShrinePositionTable = {}

Pugna.heroList = { 
	"npc_dota_hero_axe",
	"npc_dota_hero_rattletrap", 
	"npc_dota_hero_skywrath_mage",
	"npc_dota_hero_tiny",
	"npc_dota_hero_windrunner",
	"npc_dota_hero_ember_spirit",
	"npc_dota_hero_ursa",
	"npc_dota_hero_templar_assassin",
	"npc_dota_hero_legion_commander",
	"npc_dota_hero_shredder",
	"npc_dota_hero_slardar",
	"npc_dota_hero_clinkz",
	"npc_dota_hero_queenofpain",
	"npc_dota_hero_sven",
	"npc_dota_hero_visage",
	"npc_dota_hero_morphling",
	"npc_dota_hero_puck",
	"npc_dota_hero_invoker",
	"npc_dota_hero_arc_warden",
	"npc_dota_hero_furion",
	"npc_dota_hero_antimage",
	"npc_dota_hero_phantom_assassin",
	"npc_dota_hero_zuus",
	"npc_dota_hero_huskar",
	"npc_dota_hero_necrolyte",
	"npc_dota_hero_obsidian_destroyer",
	"npc_dota_hero_silencer",
	"npc_dota_hero_nevermore",
	"npc_dota_hero_dazzle",
	"npc_dota_hero_dark_willow",
	"npc_dota_hero_centaur",
	"npc_dota_hero_magnataur",
	"npc_dota_hero_ogre_magi",
	"npc_dota_hero_ancient_apparition",
	"npc_dota_hero_nyx_assassin",
	"npc_dota_hero_night_stalker",
	"npc_dota_hero_chaos_knight",
	"npc_dota_hero_witch_doctor",
	"npc_dota_hero_shadow_shaman",
	"npc_dota_hero_death_prophet",
	"npc_dota_hero_crystal_maiden",
	"npc_dota_hero_lion",
	"npc_dota_hero_pugna",
	"npc_dota_hero_undying",
	"npc_dota_hero_viper",
	"npc_dota_hero_pudge",
	"npc_dota_hero_vengefulspirit"
		}


Pugna.JunglePositionTable = {
	{ Vector(-1845, -4214, 0), "radiant", "bot", "hard" },
	{ Vector(4591, -4354, 0), "radiant", "bot", "hard" },
	{ Vector(-416, -3345, 0), "radiant", "bot", "medium" },
	{ Vector(381, -4680, 0), "radiant", "bot", "medium" },
	{ Vector(2889, -4558, 0), "radiant", "bot", "small" },
	{ Vector(-4862, -477, 0), "radiant", "top", "hard" },
	{ Vector(-3707, 878, 0), "radiant", "top", "medium" },
	{ Vector(1349, 3317, 0), "dire", "top", "hard" },
	{ Vector(-4283, 3474, 0), "dire", "top", "hard" },
	{ Vector(-227, 3396, 0), "dire", "top", "medium" },
	{ Vector(-2000, 4275, 0), "dire", "top", "medium" },
	{ Vector(-2677, 4593, 0), "dire", "top", "small" },
	{ Vector(4411, 847, 0), "dire", "bot", "hard" },
	{ Vector(2554, 81, 0), "dire", "bot", "medium" } 
		}

Pugna.invokerInvokeOrder = {
	invoker_sun_strike = { 2, 2, 2 },
	invoker_emp = { 1, 1, 1 },
	invoker_tornado = { 0, 1, 1 },
	invoker_alacrity = { 1, 1, 2 },
	invoker_ghost_walk = { 0, 0, 1 },
	invoker_deafening_blast = { 0, 1, 2 },
	invoker_chaos_meteor = { 1, 2, 2 },
	invoker_cold_snap = { 0, 0, 0 },
	invoker_ice_wall = { 0, 0, 2 },
	invoker_forge_spirit = { 0, 2, 2 } }

Pugna.invokerTornadoLiftDuration = { 0.8, 1.1, 1.4, 1.7, 2.0, 2.3, 2.6, 2.9 }

Pugna.orbAttackTable = {
	npc_dota_hero_clinkz = "clinkz_searing_arrows",
	npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
	npc_dota_hero_enchantress = "enchantress_impetus",
	npc_dota_hero_huskar = "huskar_burning_spear",
	npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
	npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
	npc_dota_hero_viper = "viper_poison_attack"
			}

Pugna.attackPointTable = {
	npc_dota_hero_abaddon = { 0.56, 0.41, 0 },
	npc_dota_hero_alchemist = { 0.35, 0.65, 0 },
	npc_dota_hero_ancient_apparition = { 0.45, 0.3, 1250 },
	npc_dota_hero_antimage = { 0.3, 0.6, 0 },
	npc_dota_hero_arc_warden = { 0.3, 0.7, 800 },
	npc_dota_hero_axe = { 0.5, 0.5, 0 },
	npc_dota_hero_bane = { 0.3, 0.7, 900 },
	npc_dota_hero_batrider = { 0.3, 0.54, 900 },
	npc_dota_hero_beastmaster = { 0.3, 0.7, 0 },
	npc_dota_hero_bloodseeker = { 0.43, 0.74, 0 },
	npc_dota_hero_bounty_hunter = { 0.59, 0.59, 0 },
	npc_dota_hero_brewmaster = { 0.35, 0.65, 0 },
	npc_dota_hero_bristleback = { 0.3, 0.3, 0 },
	npc_dota_hero_broodmother = { 0.4, 0.5, 0 },
	npc_dota_hero_centaur = { 0.3, 0.3, 0 },
	npc_dota_hero_chaos_knight = { 0.5, 0.5, 0 },
	npc_dota_hero_chen = { 0.5, 0.5, 1100 },
	npc_dota_hero_clinkz = { 0.7, 0.3, 900 },
	npc_dota_hero_rattletrap = { 0.33, 0.64, 0 },
	npc_dota_hero_crystal_maiden = { 0.55, 0, 900 },
	npc_dota_hero_dark_seer = { 0.59, 0.58, 0 },
	npc_dota_hero_dazzle = { 0.3, 0.3, 1200 },
	npc_dota_hero_death_prophet = { 0.56, 0.51, 1000 },
	npc_dota_hero_disruptor = { 0.4, 0.5, 1200 },
	npc_dota_hero_doom_bringer = { 0.5, 0.7, 0 },
	npc_dota_hero_dragon_knight = { 0.5, 0.5, 900 },
	npc_dota_hero_drow_ranger = { 0.7, 0.3, 1250 },
	npc_dota_hero_earth_spirit = { 0.35, 0.65, 0 },
	npc_dota_hero_earthshaker = { 0.467, 0.863, 0 },
	npc_dota_hero_elder_titan = { 0.35, 0.97, 0 },
	npc_dota_hero_ember_spirit = { 0.4, 0.3, 0 },
	npc_dota_hero_enchantress = { 0.3, 0.7, 900 },
	npc_dota_hero_enigma = { 0.4, 0.77, 900 },
	npc_dota_hero_faceless_void = { 0.5, 0.56, 0 },
	npc_dota_hero_gyrocopter = { 0.2, 0.97, 3000 },
	npc_dota_hero_huskar = { 0.4, 0.5, 1400 },
	npc_dota_hero_invoker = { 0.4, 0.7, 900 },
	npc_dota_hero_wisp = { 0.15, 0.4, 1200 },
	npc_dota_hero_jakiro = { 0.4, 0.5, 1100 },
	npc_dota_hero_juggernaut = { 0.33, 0.84, 0 },
	npc_dota_hero_keeper_of_the_light = { 0.3, 0.85, 900 },
	npc_dota_hero_kunkka = { 0.4, 0.3, 0 },
	npc_dota_hero_legion_commander = { 0.46, 0.64, 0 },
	npc_dota_hero_leshrac = { 0.4, 0.77, 900 },
	npc_dota_hero_lich = { 0.46, 0.54, 900 },
	npc_dota_hero_life_stealer = { 0.39, 0.44, 0 },
	npc_dota_hero_lina = { 0.75, 0.78, 1000 },
	npc_dota_hero_lion = { 0.43, 0.74, 1000 },
	npc_dota_hero_lone_druid = { 0.33, 0.53, 900 },
	npc_dota_hero_luna = { 0.46, 0.54, 900 },
	npc_dota_hero_lycan = { 0.55, 0.55, 0 },
	npc_dota_hero_magnataur = { 0.5, 0.84, 0 },
	npc_dota_hero_medusa = { 0.5, 0.6, 1200 },
	npc_dota_hero_meepo = { 0.38, 0.6, 0 },
	npc_dota_hero_mirana = { 0.3, 0.7, 900 },
	npc_dota_hero_morphling = { 0.45, 0.2, 0 },
	npc_dota_hero_monkey_king = { 0.5, 0.5, 1300 },
	npc_dota_hero_naga_siren = { 0.5, 0.5, 0 },
	npc_dota_hero_furion = { 0.4, 0.77, 1125 },
	npc_dota_hero_necrolyte = { 0.53, 0.47, 900 },
	npc_dota_hero_night_stalker = { 0.55, 0.55, 0 },
	npc_dota_hero_nyx_assassin = { 0.46, 0.54, 0 },
	npc_dota_hero_ogre_magi = { 0.3, 0.3, 0 },
	npc_dota_hero_omniknight = { 0.433, 0.567, 0 },
	npc_dota_hero_oracle = { 0.3, 0.7, 900 },
	npc_dota_hero_obsidian_destroyer = { 0.46, 0.54, 900 },
	npc_dota_hero_phantom_assassin = { 0.3, 0.7, 0 },
	npc_dota_hero_phantom_lancer = { 0.5, 0.5, 0 },
	npc_dota_hero_phoenix = { 0.35, 0.633, 1100 },
	npc_dota_hero_puck = { 0.5, 0.8, 900 },
	npc_dota_hero_pudge = { 0.5, 1.17, 0 },
	npc_dota_hero_pugna = { 0.5, 0.5, 900 },
	npc_dota_hero_queenofpain = { 0.56, 0.41, 1500 },
	npc_dota_hero_razor = { 0.3, 0.7, 2000 },
	npc_dota_hero_riki = { 0.3, 0.3, 0 },
	npc_dota_hero_rubick = { 0.4, 0.77, 1125 },
	npc_dota_hero_sand_king = { 0.53, 0.47, 0 },
	npc_dota_hero_shadow_demon = { 0.35, 0.5, 900 },
	npc_dota_hero_nevermore = { 0.5, 0.54, 1200 },
	npc_dota_hero_shadow_shaman = { 0.3, 0.5, 900 },
	npc_dota_hero_silencer = { 0.5, 0.5, 1000 },
	npc_dota_hero_skywrath_mage = { 0.4, 0.78, 1000 },
	npc_dota_hero_slardar = { 0.36, 0.64, 0 },
	npc_dota_hero_slark = { 0.5, 0.3, 0 },
	npc_dota_hero_sniper = { 0.17, 0.7, 3000 },
	npc_dota_hero_spectre = { 0.3, 0.7, 0 },
	npc_dota_hero_spirit_breaker = { 0.6, 0.3, 0 },
	npc_dota_hero_storm_spirit = { 0.5, 0.3, 1100 },
	npc_dota_hero_sven = { 0.4, 0.3, 0 },
	npc_dota_hero_techies = { 0.5, 0.5, 900 },
	npc_dota_hero_templar_assassin = { 0.3, 0.5, 900 },
	npc_dota_hero_terrorblade = { 0.3, 0.6, 0 },
	npc_dota_hero_tidehunter = { 0.6, 0.56, 0 },
	npc_dota_hero_shredder = { 0.36, 0.64, 0 },
	npc_dota_hero_tinker = { 0.35, 0.65, 900 },
	npc_dota_hero_tiny = { 0.49, 1, 0 },
	npc_dota_hero_treant = { 0.6, 0.4, 0 },
	npc_dota_hero_troll_warlord = { 0.3, 0.3, 1200 },
	npc_dota_hero_tusk = { 0.36, 0.64, 0 },
	npc_dota_hero_abyssal_underlord = { 0.45, 0.7, 0 },
	npc_dota_hero_undying = { 0.3, 0.3, 0 },
	npc_dota_hero_ursa = { 0.3, 0.3, 0 },
	npc_dota_hero_vengefulspirit = { 0.33, 0.64, 1500 },
	npc_dota_hero_venomancer = { 0.3, 0.7, 900 },
	npc_dota_hero_viper = { 0.33, 1, 1200 },
	npc_dota_hero_visage = { 0.46, 0.54, 900 },
	npc_dota_hero_warlock = { 0.3, 0.3, 1200 },
	npc_dota_hero_weaver = { 0.64, 0.36, 900 },
	npc_dota_hero_windrunner = { 0.4, 0.3, 1250 },
	npc_dota_hero_winter_wyvern = { 0.25, 0.8, 700 },
	npc_dota_hero_witch_doctor = { 0.4, 0.5, 1200 },
	npc_dota_hero_skeleton_king = { 0.56, 0.44, 0 },
	npc_dota_hero_zuus = { 0.633, 0.366, 1100 },
	npc_dota_hero_dark_willow = { 0.3, 0.7, 1200 },
	npc_dota_hero_pangolier = { 0.33, 0.67, 0 } }




Pugna.AbilityList = {
	{ "npc_dota_hero_abaddon", "abaddon_death_coil", "nuke", "target" , "target_damage" },
	{ "npc_dota_hero_abaddon", "abaddon_frostmourne", "utility", "0" , "0" },
	{ "npc_dota_hero_abaddon", "abaddon_aphotic_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_abaddon", "abaddon_borrowed_time", "utility", "0" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_pit_of_malice", "disable", "position" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_firestorm", "nuke", "position" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_atrophy_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_dark_rift", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_unstable_concoction", "disable", "target" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_unstable_concoction_throw", "disable", "target" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_acid_spray", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_chemical_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_goblins_greed", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_blast", "nuke", "position" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_blast_release", "nuke", "position" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_chilling_touch", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_cold_feet", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_vortex", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_mana_void"    , "nuke", "target" , "0" },
	{ "npc_dota_hero_antimage", "antimage_blink", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_mana_break", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_spell_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_flux", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_magnetic_field", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_spark_wraith", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_tempest_double", "utility", "0" , "0" },
	{ "npc_dota_hero_axe", "axe_berserkers_call", "disable", "no target" , "0" },
	{ "npc_dota_hero_axe", "axe_culling_blade", "nuke", "target" , "damage" },
	{ "npc_dota_hero_axe", "axe_battle_hunger", "utility", "0" , "0" },
	{ "npc_dota_hero_axe", "axe_counter_helix", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_brain_sap", "pure", "target" , "brain_sap_damage" },
	{ "npc_dota_hero_bane", "bane_fiends_grip", "nuke", "target" , "0" },
	{ "npc_dota_hero_bane", "bane_enfeeble", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_nightmare", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_nightmare_end", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_firefly", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_flamebreak", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_flaming_lasso", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_sticky_napalm", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_wild_axes", "nuke", "position" , "axe_damage" },
	{ "npc_dota_hero_beastmaster", "beastmaster_primal_roar", "disable", "no target" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_boar_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_call_of_the_wild", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_call_of_the_wild_boar", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_greater_boar_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_hawk_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_inner_beast", "utility", "0" , "0" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_blood_bath", "nuke", "position" , "damage" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_rupture", "utility", "0" , "0" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_thirst", "utility", "0" , "0" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_shuriken_toss", "nuke", "target" , "bonus_damage" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_jinada", "utility", "0" , "0" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_track", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_thunder_clap", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_hurl_boulder", "disable", "target" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_drunken_brawler", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_drunken_haze", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_pulverize", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_spell_immunity", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_fire_permanent_immolation", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_primal_split", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_cyclone", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_dispel_magic", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_wind_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_quill_spray", "nuke", "no target" , "quill_base_damage" },
	{ "npc_dota_hero_bristleback", "bristleback_bristleback", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_viscous_nasal_goo", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_warpath", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spawn_spiderlings", "nuke", "target" , "damage" },
	{ "npc_dota_hero_broodmother", "broodmother_incapacitating_bite", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_insatiable_hunger", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_poison_sting", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spawn_spiderite", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spin_web", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spin_web_destroy"  , "utility", "0" , "0" },
	{ "npc_dota_hero_centaur", "centaur_double_edge", "nuke", "no target" , "edge_damage" },
	{ "npc_dota_hero_centaur", "centaur_hoof_stomp", "disable", "no target" , "0" },
	{ "npc_dota_hero_centaur", "centaur_return", "utility", "0" , "0" },
	{ "npc_dota_hero_centaur", "centaur_stampede", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_chaos_bolt", "disable", "target" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_chaos_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_phantasm", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_reality_rift", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_test_of_faith", "pure", "target" , "damage_min" },
	{ "npc_dota_hero_chen", "chen_hand_of_god", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_holy_persuasion", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_penitence", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_test_of_faith_teleport", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_death_pact", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_searing_arrows", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_strafe", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_wind_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_crystal_nova", "nuke", "position" , "nova_damage" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_frostbite", "disable", "target" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_freezing_field", "nuke", "no target" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_brilliance_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_ion_shell", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_surge", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_vacuum", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_wall_of_replica", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_poison_touch", "nuke", "target" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_shadow_wave", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_shallow_grave", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_weave", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_carrion_swarm", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_exorcism", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_spirit_siphon", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_witchcraft", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_thunder_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_glimpse", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_kinetic_field", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_static_storm", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_devour", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_doom", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_infernal_blade", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_scorched_earth", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_dragon_tail", "disable", "target" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_breathe_fire", "nuke", "position" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_dragon_blood", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_elder_dragon_form", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_frost_breath", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_wave_of_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_frost_arrows", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_marksmanship", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_trueshot", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_boulder_smash", "disable", "position" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_geomagnetic_grip", "disable", "position" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_magnetize", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_petrify", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_rolling_boulder", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_stone_caller", "utility", "0" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_aftershock", "disable", "no target" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_fissure", "disable", "position" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_echo_slam", "nuke", "no target" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_enchant_totem", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_ancestral_spirit", "nuke", "position" , "pass_damage" },
	{ "npc_dota_hero_elder_titan", "elder_titan_echo_stomp_spirit", "disable", "no target" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_earth_splitter", "nuke", "position" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_natural_order", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_echo_stomp", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_natural_order_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_return_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_searing_chains", "disable", "no target" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_activate_fire_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_fire_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_flame_guard", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_sleight_of_fist", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_impetus", "nuke", "target" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_enchant", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_natures_attendants", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_untouchable", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_black_hole", "disable", "position" , "0" },
	{ "npc_dota_hero_enigma", "enigma_demonic_conversion", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_malefice", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_midnight_pulse", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_chronosphere", "disable", "position" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_backtrack", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_dilation", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_lock", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_force_of_nature", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_sprout", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_teleportation", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_wrath_of_nature", "utility", "0" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_call_down", "nuke", "position" , "damage_first" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_homing_missile", "disable", "target" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_rocket_barrage", "nuke", "no target" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_flak_cannon", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_berserkers_blood", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_burning_spear", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_inner_vitality", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_life_break", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_cold_snap", "disable", "no target" , "0" },
	{ "npc_dota_hero_invoker", "invoker_tornado", "disable", "position" , "0" },
	{ "npc_dota_hero_invoker", "invoker_alacrity", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_attribute_bonus", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_chaos_meteor", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_deafening_blast", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_emp", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_exort", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_forge_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_ghost_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_ice_wall", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_invoke", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_quas", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_sun_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_wex", "utility", "0" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_ice_path", "disable", "position" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_macropyre", "nuke", "position" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_dual_breath", "utility", "0" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_liquid_fire", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_omni_slash", "nuke", "target" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_blade_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_blade_fury", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_healing_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_blinding_light", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_chakra_magic", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_illuminate", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_illuminate_end", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_mana_leak", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_recall", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form_illuminate", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form_illuminate_end", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_ghostship", "nuke", "position" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_torrent", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_return", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_tidebringer", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_x_marks_the_spot", "utility", "0" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_overwhelming_odds", "nuke", "position" , "damage" },
	{ "npc_dota_hero_legion_commander", "legion_commander_duel", "disable", "target" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_moment_of_courage", "utility", "0" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_press_the_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_split_earth", "disable", "position" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_lightning_storm", "nuke", "target" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_pulse_nova", "utility", "0" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_diabolic_edict", "utility", "0" , "0" },
	{ "npc_dota_hero_lich", "lich_chain_frost", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lich", "lich_frost_nova", "nuke", "position" , "aoe_damage" },
	{ "npc_dota_hero_lich", "lich_dark_ritual", "utility", "0" , "0" },
	{ "npc_dota_hero_lich", "lich_frost_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_assimilate", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_assimilate_eject", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_consume", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_control", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_1", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_2", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_3", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_4", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_feast", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_infest", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_open_wounds", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_lina", "lina_laguna_blade", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lina", "lina_light_strike_array", "disable", "position" , "0" },
	{ "npc_dota_hero_lina", "lina_dragon_slave", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_lina", "lina_fiery_soul", "utility", "0" , "0" },
	{ "npc_dota_hero_lion", "lion_finger_of_death", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lion", "lion_impale", "disable", "position" , "0" },
	{ "npc_dota_hero_lion", "lion_voodoo", "disable", "target" , "0" },
	{ "npc_dota_hero_lion", "lion_mana_drain", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_rabid", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_savage_roar", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_savage_roar_bear", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_demolish", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_entangle", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_return", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form_battle_cry", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form_druid", "utility", "0" , "0" },
	{ "npc_dota_hero_luna", "luna_lucent_beam", "nuke", "target" , "beam_damage" },
	{ "npc_dota_hero_luna", "luna_eclipse", "nuke", "no target" , "0" },
	{ "npc_dota_hero_luna", "luna_lunar_blessing", "utility", "0" , "0" },
	{ "npc_dota_hero_luna", "luna_moon_glaive", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_feral_impulse", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_howl", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_shapeshift", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves_critical_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_shockwave", "nuke", "skillshot" , "shock_damage" },
	{ "npc_dota_hero_magnataur", "magnataur_reverse_polarity", "disable", "no target" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_empower", "utility", "0" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_skewer", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_mystic_snake", "pure", "target" , "snake_damage" },
	{ "npc_dota_hero_medusa", "medusa_mana_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_split_shot", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_stone_gaze", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_earthbind", "disable", "position" , "0" },
	{ "npc_dota_hero_meepo", "meepo_poof", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_divided_we_stand", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_geostrike", "utility", "0" , "0" },
	{ "npc_dota_hero_mirana", "mirana_arrow", "disable", "position" , "0" },
	{ "npc_dota_hero_mirana", "mirana_starfall", "nuke", "no target" , "0" },
	{ "npc_dota_hero_mirana", "mirana_invis", "utility", "0" , "0" },
	{ "npc_dota_hero_mirana", "mirana_leap", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_primal_spring", "disable", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_primal_spring_early", "disable", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_boundless_strike", "nuke", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_jingu_mastery", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_mischief", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_tree_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_untransform", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_wukongs_command", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_adaptive_strike_agi", "nuke", "target" , "damage_base" },
	{ "npc_dota_hero_morphling", "morphling_waveform", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_hybrid", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_agi", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_replicate", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_str", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_replicate", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_ensnare", "disable", "target" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_rip_tide", "nuke", "no target" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_mirror_image", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_song_of_the_siren", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_song_of_the_siren_cancel", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_reapers_scythe", "disable", "target" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_death_pulse", "nuke", "no target" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_heartstopper_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_sadist", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_sadist_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_dark_lord", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_necromastery", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_requiem", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze1", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze2", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze3", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_night_stalker", "night_stalker_void", "nuke", "target" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_crippling_fear", "utility", "0" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_darkness", "utility", "0" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_hunter_in_the_night", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_impale", "disable", "position" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_mana_burn", "nuke", "special" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_burrow", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_spiked_carapace", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_unburrow", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_vendetta", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_astral_imprisonment", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_sanity_eclipse", "nuke", "position" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_arcane_orb", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_essence_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_mind_over_matter", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_fireblast", "nuke", "target" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_unrefined_fireblast", "nuke", "target" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_bloodlust", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_ignite", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_multicast", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_degen_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_guardian_angel", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_purification", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_repel", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_fortunes_end", "disable", "target" , "0" },
	{ "npc_dota_hero_oracle", "oracle_false_promise", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_fates_edict", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_purifying_flames", "nuke", "target" , "damage" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_stifling_dagger", "nuke", "target" , "base_damage" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_blur", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_coup_de_grace", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_phantom_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_spirit_lance", "nuke", "target" , "lance_damage" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_doppelwalk", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_juxtapose", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_phantom_edge", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_fire_spirits", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_icarus_dive", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_icarus_dive_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_launch_fire_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_toggle_move", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_toggle_move_empty", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_supernova", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_dream_coil", "disable", "position" , "0" },
	{ "npc_dota_hero_puck", "puck_waning_rift", "disable", "no target" , "damage" },
	{ "npc_dota_hero_puck", "puck_ethereal_jaunt", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_illusory_orb", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_phase_shift", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_dismember", "disable", "target" , "0" },
	{ "npc_dota_hero_pudge", "pudge_flesh_heap", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_meat_hook", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_rot", "utility", "0" , "0" },
	{ "npc_dota_hero_pugna", "pugna_nether_blast", "nuke", "skillshot" , "blast_damage" },
	{ "npc_dota_hero_pugna", "pugna_life_drain", "nuke", "target" , "0" },
	{ "npc_dota_hero_pugna", "pugna_decrepify", "utility", "0" , "0" },
	{ "npc_dota_hero_pugna", "pugna_nether_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_queenofpain", "queenofpain_sonic_wave", "nuke", "position" , "damage" },
	{ "npc_dota_hero_queenofpain", "queenofpain_shadow_strike", "nuke", "target" , "strike_damage" },
	{ "npc_dota_hero_queenofpain", "queenofpain_scream_of_pain", "nuke", "special" , "0" },
	{ "npc_dota_hero_queenofpain", "queenofpain_blink", "utility", "0" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_battery_assault", "disable", "no target" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_hookshot", "disable", "position" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_rocket_flare", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_power_cogs", "utility", "0" , "0" },
	{ "npc_dota_hero_razor", "razor_plasma_field", "nuke", "no target" , "damage_max" },
	{ "npc_dota_hero_razor", "razor_eye_of_the_storm", "nuke", "no target" , "0" },
	{ "npc_dota_hero_razor", "razor_static_link", "utility", "0" , "0" },
	{ "npc_dota_hero_razor", "razor_unstable_current", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_smoke_screen", "disable", "position" , "0" },
	{ "npc_dota_hero_riki", "riki_blink_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_permanent_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_tricks_of_the_trade", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_fade_bolt", "nuke", "target" , "damage" },
	{ "npc_dota_hero_rubick", "rubick_telekinesis", "disable", "target" , "0" },
	{ "npc_dota_hero_rubick", "rubick_telekinesis_land", "disable", "target" , "0" },
	{ "npc_dota_hero_rubick", "rubick_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden1", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden2", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden3", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_null_field", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_spell_steal", "utility", "0" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_burrowstrike", "disable", "position" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_epicenter", "nuke", "no target" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_caustic_finale", "utility", "0" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_sand_storm", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_demonic_purge", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_disruption", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_shadow_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_shadow_poison_release", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_soul_catcher", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_ether_shock", "nuke", "target" , "damage" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_shackles", "disable", "target" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_voodoo", "disable", "target" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_mass_serpent_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_whirling_death", "pure", "no target" , "whirling_damage" },
	{ "npc_dota_hero_shredder", "shredder_chakram", "nuke", "position" , "0" },
	{ "npc_dota_hero_shredder", "shredder_chakram_2", "nuke", "position" , "0" },
	{ "npc_dota_hero_shredder", "shredder_reactive_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_return_chakram", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_return_chakram_2", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_timber_chain", "utility", "0" , "0" },
	{ "npc_dota_hero_silencer", "silencer_last_word", "nuke", "target" , "damage" },
	{ "npc_dota_hero_silencer", "silencer_global_silence", "disable", "no target" , "0" },
	{ "npc_dota_hero_silencer", "silencer_curse_of_the_silent", "utility", "0" , "0" },
	{ "npc_dota_hero_silencer", "silencer_glaives_of_wisdom", "utility", "0" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_hellfire_blast", "disable", "target" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_reincarnation", "utility", "0" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_vampiric_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_arcane_bolt", "nuke", "target" , "bolt_damage" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_ancient_seal", "disable", "target" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_mystic_flare", "nuke", "position" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_concussive_shot", "nuke", "special" , "damage" },
	{ "npc_dota_hero_slardar", "slardar_slithereen_crush", "disable", "no target" , "0" },
	{ "npc_dota_hero_slardar", "slardar_amplify_damage", "utility", "0" , "0" },
	{ "npc_dota_hero_slardar", "slardar_bash", "utility", "0" , "0" },
	{ "npc_dota_hero_slardar", "slardar_sprint", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_dark_pact", "nuke", "no target" , "total_damage" },
	{ "npc_dota_hero_slark", "slark_essence_shift", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_pounce", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_shadow_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_assassinate", "nuke", "target" , "0" },
	{ "npc_dota_hero_sniper", "sniper_headshot", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_shrapnel", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_take_aim", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_spectral_dagger", "nuke", "target" , "damage" },
	{ "npc_dota_hero_spectre", "spectre_desolate", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_dispersion", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_haunt", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_reality", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_nether_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_charge_of_darkness", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_empowering_haste", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_greater_bash", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_electric_vortex", "disable", "target" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_ball_lightning", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_overload", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_static_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_storm_bolt", "disable", "target" , "0" },
	{ "npc_dota_hero_sven", "sven_gods_strength", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_great_cleave", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_warcry", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_land_mines", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_stasis_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_suicide", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_remote_mines", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_focused_detonate", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_remote_mines_self_detonate", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_minefield_sign", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_meld", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_psi_blades", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_psionic_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_refraction", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_self_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_conjure_image", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_metamorphosis", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_reflection", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_sunder", "utility", "0" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_ravage", "disable", "no target" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_anchor_smash", "nuke", "no target" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_gush", "nuke", "target" , "gush_damage" },
	{ "npc_dota_hero_tidehunter", "tidehunter_kraken_shell", "utility", "0" , "0" },
	{ "npc_dota_hero_tinker", "tinker_laser", "pure", "target" , "laser_damage" },
	{ "npc_dota_hero_tinker", "tinker_heat_seeking_missile", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_tinker", "tinker_march_of_the_machines", "utility", "0" , "0" },
	{ "npc_dota_hero_tinker", "tinker_rearm", "utility", "0" , "0" },
	{ "npc_dota_hero_tiny", "tiny_toss", "nuke", "position" , "toss_damage" },
	{ "npc_dota_hero_tiny", "tiny_avalanche", "disable", "position" , "avalanche_damage" },
	{ "npc_dota_hero_tiny", "tiny_craggy_exterior", "utility", "0" , "0" },
	{ "npc_dota_hero_tiny", "tiny_grow", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_overgrowth", "disable", "no target" , "0" },
	{ "npc_dota_hero_treant", "treant_eyes_in_the_forest", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_leech_seed", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_living_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_natures_guise", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_battle_trance", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_berserkers_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_fervor", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_whirling_axes_melee", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_whirling_axes_ranged", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_ice_shards", "nuke", "skillshot" , "shard_damage" },
	{ "npc_dota_hero_tusk", "tusk_walrus_kick", "nuke", "target" , "0" },
	{ "npc_dota_hero_tusk", "tusk_walrus_punch", "nuke", "target" , "0" },
	{ "npc_dota_hero_tusk", "tusk_frozen_sigil", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_launch_snowball", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_snowball", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_decay", "nuke", "position" , "decay_damage" },
	{ "npc_dota_hero_undying", "undying_flesh_golem", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_soul_rip", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone_zombie_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone_zombie_deathstrike", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_earthshock", "nuke", "no target" , "0" },
	{ "npc_dota_hero_ursa", "ursa_enrage", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_fury_swipes", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_overpower", "utility", "0" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_magic_missile", "disable", "target" , "magic_missile_damage" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_wave_of_terror", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_command_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_nether_swap", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_plague_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_poison_nova", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_poison_sting", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_venomous_gale", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_viper_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_viper", "viper_corrosive_skin", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_nethertoxin", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_poison_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_soul_assumption", "utilit<", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_grave_chill", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_gravekeepers_cloak", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_summon_familiars", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_summon_familiars_stone_form", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_rain_of_chaos", "disable", "position" , "0" },
	{ "npc_dota_hero_warlock", "warlock_shadow_word", "nuke", "target" , "0" },
	{ "npc_dota_hero_warlock", "warlock_fatal_bonds", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_golem_flaming_fists", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_golem_permanent_immolation", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_upheaval", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_geminate_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_shukuchi", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_the_swarm", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_time_lapse", "utility", "0" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_shackleshot", "disable", "target" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_powershot", "nuke", "skillshot" , "powershot_damage" },
	{ "npc_dota_hero_windrunner", "windrunner_focusfire", "utility", "0" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_windrun", "utility", "0" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_winters_curse", "disable", "target" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_splinter_blast", "nuke", "special" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_arctic_burn", "utility", "0" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_cold_embrace", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_overcharge", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_relocate", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits_in", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits_out", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_tether", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_tether_break", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_paralyzing_cask", "disable", "target" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_death_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_maledict", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_voodoo_restoration", "utility", "0" , "0" },
	{ "npc_dota_hero_zuus", "zuus_arc_lightning", "nuke", "target" , "arc_damage" },
	{ "npc_dota_hero_zuus", "zuus_lightning_bolt", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_zuus", "zuus_thundergods_wrath", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_zuus", "zuus_cloud", "utility", "0" , "0" },
	{ "npc_dota_hero_zuus", "zuus_static_field", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_bramble_maze", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_shadow_realm", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_cursed_crown", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_bedlam", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_terrorize", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_swashbuckle", "nuke", "special", "damage" },
	{ "npc_dota_hero_pangolier", "pangolier_shield_crash", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_heartpiercer", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_gyroshell", "utility", "0" , "0" } }


Pugna.RawDamageAbilityEstimation = {
	zuus_thundergods_wrath = { "no target", 0, 99999, 150, 0, 0 },
	puck_waning_rift = { "no target", 0, 400, 75, 0, 0 },
	ogre_magi_fireblast = { "target", 0, 0, 75, 0, 0 },
	obsidian_destroyer_astral_imprisonment = { "target", 0, 0, 75, 0, 0 },
	obsidian_destroyer_sanity_eclipse = { "position", 700, 575, 250, 0, 0 },
	necrolyte_reapers_scythe = { "target", 0, 0, 250, 0, 0 },
	magnataur_reverse_polarity = { "no target", 0, 410, 200, 0, 0 },
	lion_finger_of_death = { "target", 0, 0, 250, 0, 0 },
	lina_laguna_blade = { "target", 0, 0, 300, 0, 0 },
	legion_commander_duel = { "target", 0, 0, 250, 0, 0 },
	earthshaker_fissure = { "position", 0, 225, 75, 0, 0 },
	doom_bringer_doom = { "target", 0, 0, 150, 0, 0 },
	centaur_hoof_stomp = { "no target", 0, 315, 75, 0, 0 },
	bloodseeker_rupture = { "target", 0, 0, 150, 0, 0 },
	antimage_mana_void = { "position", 600, 500, 250, 0, 0 },
	queenofpain_sonic_wave = { "position", 0, 450, 170, 900, 0 },
	pudge_dismember = { "target", 0, 0, 75, 0, 0 },
	slardar_slithereen_crush = { "no target", 0, 350, 75, 0, 0 },
	bane_brain_sap = { "target", 0, 0, 75, 0, 0 },
	bane_fiends_grip = { "target", 0, 0, 500, 0, 0 },
	beastmaster_wild_axes = { "position", 0, 250, 75, 1200, 0 },
	bloodseeker_blood_bath = { "position", 0, 600, 60, 0, 2.6 },
	brewmaster_thunder_clap = { "no target", 0, 400, 75, 0, 0 },
	centaur_double_edge = { "target", 190, 0, 100, 0, 0 },
	chen_test_of_faith = { "target", 0, 0, 75, 0, 0 },
	crystal_maiden_crystal_nova = { "position", 0, 425, 75, 0, 0 },
	dragon_knight_breathe_fire = { "position", 0, 250, 75, 1050, 0 },
	gyrocopter_call_down = { "position", 0, 600, 150, 0, 2 },
	kunkka_torrent = { "position", 0, 225, 75, 0, 1.6 },
	zuus_lightning_bolt = { "position", 0, 325, 75, 0, 0 },
	legion_commander_overwhelming_odds = { "position", 0, 330, 75, 0, 0 },
	beastmaster_primal_roar = { "no target", 950, 300, 100, 0, 0 },
	bristleback_quill_spray = { "no target", 0, 700, 30, 2400, 0 },
	crystal_maiden_freezing_field = { "no target", 0, 835, 150, 0, 0 },
	dazzle_poison_touch = { "target", 0, 0, 50, 0, 0 },
	death_prophet_carrion_swarm = { "position", 0, 300, 75, 1100, 0 },
	earth_spirit_boulder_smash = { "target", 0, 0, 50, 0, 0 },	
	invoker_tornado = { "position", 0, 200, 300, 1000, 0 },
	invoker_chaos_meteor = { "position", 0, 275, 400, 0, 1.3 },
	invoker_deafening_blast = { "position", 0, 225, 300, 1100, 0 },
	invoker_emp = { "position", 0, 675, 300, 0, 2.9 },	
	jakiro_macropyre = { "position", 0, 260, 125, 0, 0 },
	juggernaut_omni_slash = { "target", 0, 0, 200, 0, 0 },
	kunkka_ghostship = { "position", 0, 425, 125, 650, 2.7 },	
	leshrac_split_earth = { "position", 0, 225, 75, 0, 0.35 },
	leshrac_lightning_storm = { "target", 0, 0, 50, 0, 0 },
	lich_frost_nova = { "position", 0, 200, 50, 0, 0 },
	lina_light_strike_array = { "position", 0, 225, 60, 0, 0.5 },
	lina_dragon_slave = { "position", 0, 275, 75, 1200, 0 },
	luna_lucent_beam = { "target", 0, 0, 75, 0, 0 },
	luna_eclipse = { "no target", 0, 675, 150, 0, 0 },	
	magnataur_shockwave = { "position", 0, 150, 75, 1050, 0 },
	meepo_poof = { "no target", 0, 375, 75, 0, 0 },
	monkey_king_boundless_strike = { "position", 0, 150, 100, 0, 0 },
	morphling_waveform = { "position", 0, 200, 75, 1250, 0 },	
	naga_siren_rip_tide = { "no target", 0, 320, 75, 0, 0 },
	nevermore_shadowraze1 = { "position", 200, 250, 75, 0, 0 },
	nevermore_shadowraze2 = { "position", 450, 250, 75, 0, 0 },
	nevermore_shadowraze3 = { "position", 700, 250, 75, 0, 0 },
	night_stalker_void = { "target", 0, 0, 75, 0, 0 },
	nyx_assassin_mana_burn = { "target", 0, 0, 75, 0, 0 },
	ogre_magi_unrefined_fireblast = { "target", 0, 0, 75, 0, 0 },
	omniknight_purification = { "position", 575, 260, 100, 0, 0 },
	oracle_purifying_flames = { "target", 0, 0, 75, 0, 0 },
	puck_dream_coil = { "position", 0, 375, 150, 0, 0 },
	pudge_meat_hook = { "position", 0, 100, 100, 1450, 0 },
	pugna_nether_blast = { "position", 0, 400, 75, 0, 0.9 },
	razor_plasma_field = { "no target", 0, 700, 80, 636, 0 },
	razor_eye_of_the_storm = { "no target", 0, 500, 100, 0, 0 },
	rubick_fade_bolt = { "target", 0, 0, 75, 0, 0 },
	rubick_telekinesis = { "target", 0, 0, 75, 0, 0 },
	sandking_burrowstrike = { "position", 0, 150, 75, 2000, 0 },
	sandking_epicenter = { "no target", 0, 525, 200, 0, 0 },
	shadow_demon_demonic_purge = { "target", 0, 0, 125, 0, 0 },
	shadow_shaman_ether_shock = { "target", 0, 0, 75, 0, 0 },
	shredder_whirling_death = { "no target", 0, 300, 75, 0, 0 },
	shredder_chakram = { "position", 0, 200, 100, 900, 0 },
	shredder_chakram_2 = { "position", 0, 200, 100, 900, 0 },
	slark_pounce = { "position", 700, 95, 60, 933.33, 0 },
	spirit_breaker_nether_strike = { "target", 0, 0, 125, 0, 1 },
	storm_spirit_static_remnant = { "no target", 0, 235, 75, 0, 0 },
	techies_suicide = { "target", 0, 0, 300 },	
	tidehunter_anchor_smash = { "no target", 0, 375, 75, 0, 0 },
	tinker_laser = { "target", 0, 0, 75, 0, 0 },
	tiny_avalanche = { "position", 0, 275, 75, 0, 0 },
	troll_warlord_whirling_axes_melee = { "no target", 0, 450, 75, 0, 0 },
	troll_warlord_whirling_axes_ranged = { "position", 0, 100, 45, 1500, 0 },
	tusk_ice_shards = { "position", 0, 200, 75, 1200, 0 },
	tusk_walrus_punch = { "target", 0, 0, 200, 0, 0 },
	undying_decay = { "position", 0, 325, 75, 0, 0 },
	ursa_earthshock = { "no target", 0, 385, 75, 0, 0 },
	vengefulspirit_wave_of_terror = { "position", 0, 300, 40, 2000, 0 },
	windrunner_powershot = { "position", 0, 125, 175, 3000, 0 },
	witch_doctor_death_ward = { "target", 0, 0, 200, 0, 0 },	
	zuus_arc_lightning = { "target", 0, 0, 35, 0, 0 },
	dark_willow_bedlam = { "no target", 0, 300, 175, 0, 0 },
	pangolier_shield_crash = { "no target", 0, 500, 75, 0, 0 },
	axe_berserkers_call = { "no target", 0, 400, 100, 0, 0 },
	batrider_flaming_lasso = { "target", 0, 0, 150, 0, 0 },
	crystal_maiden_frostbite = { "target", 0, 0, 100, 0, 0 },
	earthshaker_enchant_totem = { "no target", 0, 300, 100, 0, 0 },
	enigma_black_hole = { "position", 275, 420, 175, 0, 0 },
	faceless_void_chronosphere = { "position", 600, 600, 175, 0, 0 },
	sandking_burrowstrike = { "position", 0, 150, 100, 2000, 0 },
	shadow_shaman_shackles = { "target", 0, 0, 150, 0, 0 },
	storm_spirit_electric_vortex = { "target", 0, 0, 100, 0, 0 },
	warlock_rain_of_chaos = { "position", 0, 600, 150, 0, 0 },
	tidehunter_ravage = { "no target", 0, 1250, 150, 725, 0 },
	tidehunter_gush = { "target", 0, 0, 75, 2500, 0 }
		}

Pugna.NeutralListComplete = {
	"npc_dota_neutral_alpha_wolf",
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_centaur_outrunner",
	"npc_dota_neutral_dark_troll_warlord",
	"npc_dota_neutral_fel_beast",
	"npc_dota_neutral_ghost",
	"npc_dota_neutral_giant_wolf",
	"npc_dota_neutral_harpy_scout",
	"npc_dota_neutral_harpy_storm",
	"npc_dota_neutral_polar_furbolg_champion",
	"npc_dota_neutral_polar_furbolg_ursa_warrior",
	"npc_dota_neutral_dark_troll",
	"npc_dota_neutral_forest_troll_berserker",
	"npc_dota_neutral_forest_troll_high_priest",
	"npc_dota_neutral_kobold",
	"npc_dota_neutral_kobold_tunneler",
	"npc_dota_neutral_kobold_taskmaster",
	"npc_dota_neutral_mud_golem",
	"npc_dota_neutral_ogre_mauler",
	"npc_dota_neutral_ogre_magi",
	"npc_dota_neutral_satyr_trickster",
	"npc_dota_neutral_satyr_soulstealer",
	"npc_dota_neutral_satyr_hellcaller",
	"npc_dota_neutral_gnoll_assassin",
	"npc_dota_neutral_wildkin",
	"npc_dota_neutral_enraged_wildkin"
		}

Pugna.NeutralMainNPCsmall = {
	"npc_dota_neutral_kobold_taskmaster",
	"npc_dota_neutral_forest_troll_berserker",
	"npc_dota_neutral_gnoll_assassin",
	"npc_dota_neutral_ghost",
	"npc_dota_neutral_harpy_storm"
		}

Pugna.NeutralMainNPCmedium = {
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_alpha_wolf",
	"npc_dota_neutral_satyr_soulstealer",
	"npc_dota_neutral_ogre_mauler",
	"npc_dota_neutral_mud_golem"
		}

Pugna.NeutralMainNPChard = {
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_satyr_hellcaller",
	"npc_dota_neutral_polar_furbolg_ursa_warrior",
	"npc_dota_neutral_enraged_wildkin",
	"npc_dota_neutral_dark_troll_warlord"
		}




function Pugna.ResetGlobalVariables()
	CurentHero = nil
	Pugna.LockedTarget = nil
	Pugna.myUnitName = nil
	Pugna.lastCastTime = 0
	Pugna.lastCastTime2 = 0
	Pugna.lastCastTime3 = 0
	Pugna.lastTick = 0
	Pugna.delay = 0
	Pugna.itemDelay = 0
	Pugna.lastItemCast = 0
	Pugna.lastDefItemPop = 0
	Pugna.lastItemTick = 0
	Pugna.ItemCastStop = false
	Pugna.isArmletManuallyToggled = false
	Pugna.isArmletManuallyToggledTime = 0
	Pugna.armletDelayer = 0
	Pugna.ControlledUnitCastTime = 0
	Pugna.ControlledUnitPauseTime = 0
	Pugna.lastAttackTime = 0
	Pugna.lastAttackTime2 = 0
	Pugna.LastTarget = nil
	Pugna.LastTickManta1 = 0
	Pugna.LastTickManta2 = 0
	Pugna.ArcWardenEntity = nil
	Pugna.ArcWardenEntityAnimationStart = 0
	Pugna.ArcWardenEntityAnimationEnd = 0
	Pugna.arcWardenPanelX = 0
	Pugna.arcWardenPanelY = 0
	Pugna.ArcTempestLockedTarget = nil
	Pugna.ArcTempestLockedTargetParticle = 0
	Pugna.ArcTempestLockedTargetParticleHero = nil
	Pugna.arcWardenMagneticCastTime = 0
	Pugna.arcWardenPushMode = false
	Pugna.arcWardenPusher = false
	Pugna.arcWardenPushModeLine = false
	Pugna.arcWardenStatus = 0
	Pugna.ArcTempestLockedTargetPos = Vector()
	Pugna.ArcTempestLockedTargetPosTimer = 0
	Pugna.TempestInAttackBackswing = false
	Pugna.TempestOrbwalkerDelay = 0
	Pugna.ArcWardenEntityProjectileCreate = 0
	Pugna.GenericUpValue = false
	Pugna.lastPosition = Vector(0, 0, 0)
	Pugna.PuckOrbCastTime = 0
	Pugna.Toggler = false
	Pugna.TogglerTime = 0
	Pugna.PreInvoke = false
	Pugna.InvokerComboSelector = 0
	Pugna.InvokerLastCastedSkill = nil
	Pugna.InvokerLastCastedSkillTime = 0
	Pugna.InvokerLastChangedInstance = 0
	Pugna.InvokerCaptureManualInstances = 0
	Pugna.invokerChannellingKillstealTimer = 0
	Pugna.invokerCaptureGhostwalkActivation = 0
	Pugna.getInvokerGhostWalkKey = nil
	Pugna.invokerDisplayNeedsInit = true
	Pugna.getInvokerSettings = nil
	Pugna.InvokerCanComboStart = false
	Pugna.AttackProjectileCreate = 0
	Pugna.AttackAnimationCreate = 0
	Pugna.AttackParticleCreate = 0
	Pugna.InAttackBackswing = false
	Pugna.OrbwalkerDelay = 0
	Pugna.TPParticleIndex = nil
	Pugna.TPParticleTime = 0
	Pugna.TPParticleUnit = nil
	Pugna.TPParticlePosition = Vector()
	Pugna.GlimpseParticleIndex = nil
	Pugna.GlimpseParticleTime = 0
	Pugna.GlimpseParticleUnit = nil
	Pugna.GlimpseParticlePosition = Vector()
	Pugna.GlimpseParticleIndexStart = nil
	Pugna.GlimpseParticlePositionStart = Vector()
	Pugna.particleNextTime = 0
	Pugna.currentParticle = 0
	Pugna.currentParticleTarget = nil
	Pugna.skywrathDMGwithoutUlt = 0
	Pugna.skywrathDMGwithUlt = 0
	Pugna.skywrathComboSelect = false
	Pugna.clockwerkHookUpValue = false
	Pugna.enemyCanBeShackled = false
	Pugna.dodgeTiming = 0
	Pugna.dodgerProjectileAdjustmentTick = 0
	Pugna.saverTiming = 0
	Pugna.VisageInstStunLockTarget = nil
	Pugna.VisagePanicTarget = nil
	Pugna.morphlingComboSelect = false
	Pugna.morphlingTotalDMG = 0
	Pugna.morphlingTotalDMGwoWave = 0
	Pugna.MorphBalanceTimer = 0
	Pugna.MorphBalanceSelectedHP = 0
	Pugna.MorphBalanceSelected = 0
	Pugna.MorphBalanceToggler = true
	Pugna.wardCaptureTiming = 0
	Pugna.sentryImageHandle = nil
	Pugna.obsImageHandle = nil
	Pugna.wardDrawingRemove = 0
	Pugna.necroDMGwithoutUlt = 0
	Pugna.necroDMGwithUlt = 0
	Pugna.necroComboSelect = false
	Pugna.magnusLastPos = Vector()
	Pugna.SFcurrentParticle1 = 0
	Pugna.SFcurrentParticle2 = 0
	Pugna.SFcurrentParticle3 = 0
	Pugna.SFParticleUpdateTime = 0
	Pugna.armletRightClickToggle = false
	Pugna.armletRightClickToggleTimer = 0
	Pugna.armletRightClickDoubleClick = 0
	Pugna.isArmletActive = false
	Pugna.armletCurrentHPGain = 0
	Pugna.armletToggleTime = 0
	Pugna.armletToggleTimePingAdjuster = 0
	Pugna.armletProjectileAdjustmentTick = 0
	Pugna.armletDamageInstanceTable = {}
	Pugna.lastHitterDelay = 0
	Pugna.lastHitterOrbSkill = nil
	Pugna.lastHitterOrbSkillEnemy = nil
	Pugna.lastHitterKillableImage = nil
	Pugna.kunkkaXMarkPosition = Vector()
	Pugna.kunkkaGhostshipTimer = 0
	Pugna.kunkkaXMarkCastTime = 0
	Pugna.TinkerStatus = 0
	Pugna.TinkerPusher = false
	Pugna.TinkerPorted = false
	Pugna.TinkerJungle = false
	Pugna.TinkerMarched = 0
	Pugna.TinkerGlimmerCastTime = 0
	Pugna.TinkerPanicRearmBlink = 0
	Pugna.TinkerPanelX = 0
	Pugna.TinkerPanelY = 0
	Pugna.TinkerPushMode = false
	Pugna.TinkerPushCreeps = 3
	Pugna.TinkerPushEnemies = 0
	Pugna.TinkerPushAllies = 0
	Pugna.TinkerPushJungle = true
	Pugna.TinkerPushSave = true
	Pugna.TinkerPushDefend = true
	Pugna.PudgeRotComboActivation = false
	Pugna.PudgeRotComboDeactivation = 0
	Pugna.PudgeHookStartTimer = 0
	Pugna.PudgeHookDelayer = 0
	Pugna.PudgeHookRotDelayer = 0
	Pugna.PudgeHookTarget = nil
	Pugna.PudgeHookTargetedPos = nil
	Pugna.PudgeHookHit = false
	Pugna.PudgecurrentParticle = 0
	Pugna.PudgecurrentParticleTarget = nil
	Pugna.PudgeRotFarmToggled = false
	Pugna.PudgeRotFarmToggledTime = 0
	Pugna.TinkerJungleFarmPos = {}
	Pugna.JungleTrackTable = {}
	Pugna.ShrinePositionTable = {}
	Pugna.wardDispenserCount = {}
	Pugna.wardProcessingTable = {}
	Pugna.lastHitCreepHPPrediction = {}
	Pugna.lastHitCreepHPPredictionTime = {}
	Pugna.creepAttackPointData = {}
	Pugna.autododgerTable = {}
	Pugna.autododgerSkillReady = {}
	Pugna.autododgerReadyTable = {}
	Pugna.LinkensBreakerItemOrder = {}
	Pugna.ItemCastOrder = {}
	Pugna.rotationTable = {}
	Pugna.PuckOrbHitSim = {}
	Pugna.enemyHeroTable = {}
	Pugna.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
	Pugna.PreInvokeSkills = {}
	Pugna.invokerCachedIcons = {}
	Pugna.VisageFamiliarAttackCounter = {}
	Pugna.heroIconHandler = {}
	Pugna.itemIconHandler = {}
	Pugna.ControllableEntityTable = {}
	Pugna.ControllableAttackTiming = {}

end

function Pugna.OnGameStart()
	
	Pugna.ResetGlobalVariables()

end

function Pugna.OnGameEnd()
	
	Pugna.ResetGlobalVariables()

end

-- main callback
function Pugna.OnUpdate()
	
	if not Menu.IsEnabled(Pugna.optionEnable) then return end

	if not Engine.IsInGame() then
		FAIO.ResetGlobalVariables()
	end
	
	if GameRules.GetGameState() < 4 then return end
	if GameRules.GetGameState() > 5 then return end

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Entity.IsAlive(myHero) then return end
		if Pugna.myUnitName == nil then
			Pugna.myUnitName = NPC.GetUnitName(myHero)
		end

	if next(Pugna.ItemCastOrder) == nil then
		Pugna.setOrderItem(false)
	end

	local isHeroSupported = Pugna.heroSupported(myHero)

	local enemy = Pugna.getComboTarget(myHero)

	if Menu.IsKeyDown(Pugna.optionComboKey) then
		if Menu.GetValue(Pugna.optionTargetStyle) < 1 then
			if Pugna.LockedTarget == nil then
				if enemy then
					Pugna.LockedTarget = enemy
				else
					Pugna.LockedTarget = nil
				end
			end
		else
			if enemy then
				Pugna.LockedTarget = enemy
			else
				Pugna.LockedTarget = nil
			end
		end
	else
		Pugna.LockedTarget = nil
	end

	if Pugna.LockedTarget ~= nil then
		if not Entity.IsAlive(Pugna.LockedTarget) then
			Pugna.LockedTarget = nil
		elseif Entity.IsDormant(Pugna.LockedTarget) then
			Pugna.LockedTarget = nil
		elseif not NPC.IsEntityInRange(myHero, Pugna.LockedTarget, 3000) then
			Pugna.LockedTarget = nil
		end
	end

	if Menu.IsEnabled(Pugna.optionLockTargetIndicator) then
		Pugna.TargetIndicator(myHero)
	end
	local comboTarget
		if Pugna.LockedTarget ~= nil then
			comboTarget = Pugna.LockedTarget
		else
			if not Menu.IsKeyDown(Pugna.optionComboKey) then
				comboTarget = enemy
			end
		end
			
	if comboTarget then
		if isHeroSupported then
			if Pugna.myUnitName == "npc_dota_hero_axe" then
				Pugna.axeCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_rattletrap" then
				Pugna.clockwerkCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_skywrath_mage" then
				Pugna.skywrathCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_tiny" then
				Pugna.tinyCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_windrunner" then
				Pugna.WindRunnerCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_ember_spirit" then
				Pugna.EmberCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_ursa" then
				Pugna.UrsaCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_templar_assassin" then
				Pugna.TACombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_slardar" then
				Pugna.SlardarCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_queenofpain" then
				Pugna.QoPCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_sven" then
				Pugna.SvenCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_visage" then
				Pugna.VisageCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_puck" then
				Pugna.PuckCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_antimage" then
				Pugna.AntiMageCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_phantom_assassin" then
				Pugna.PACombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_obsidian_destroyer" then
				Pugna.ODCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_silencer" then
				Pugna.SilencerCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_dark_willow" then
				Pugna.WillowCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_dazzle" then
				Pugna.DazzleHelper(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_centaur" then
				Pugna.centaurCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_ogre_magi" then
				Pugna.OgreCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_ancient_apparition" then
				Pugna.AACombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_nyx_assassin" then
				Pugna.NyxCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_night_stalker" then
				Pugna.NSCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_chaos_knight" then
				Pugna.CKCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_witch_doctor" then
				Pugna.WDCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_shadow_shaman" then
				Pugna.SSCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_death_prophet" then
				Pugna.DPCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_crystal_maiden" then
				Pugna.CMCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_lion" then
				Pugna.LionCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_pugna" then
				Pugna.PugnaCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_undying" then
				Pugna.UndyingCombo(myHero, comboTarget)
			elseif Pugna.myUnitName == "npc_dota_hero_vengefulspirit" then
				Pugna.VSCombo(myHero, comboTarget)
			end
		end
	end



end

function Pugna.getComboTarget(myHero)

	if not myHero then return end

	local targetingRange = Menu.GetValue(Pugna.optionTargetRange)
	local mousePos = Input.GetWorldCursorPos()

	local enemyTable = Heroes.InRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)
		if #enemyTable < 1 then return end

	local nearestTarget = nil
	local distance = 99999

	for i, v in ipairs(enemyTable) do
		if v and Entity.IsHero(v) then
			if Pugna.targetChecker(v) ~= nil then
				local enemyDist = (Entity.GetAbsOrigin(v) - mousePos):Length2D()
				if enemyDist < distance then
					nearestTarget = v
					distance = enemyDist
				end
			end
		end
	end

	return nearestTarget or nil

end


function Pugna.OnParticleCreate(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	local enemy = Pugna.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(Heroes.GetLocal()), Enum.TeamType.TEAM_ENEMY))

	if particle.name == "teleport_start" then
		if particle.entityForModifiers ~= nil and particle.entityForModifiers ~= Heroes.GetLocal() then
			if not Entity.IsSameTeam(Heroes.GetLocal(), particle.entityForModifiers) then
				Pugna.TPParticleIndex = particle.index
				Pugna.TPParticleTime = GameRules.GetGameTime()
				Pugna.TPParticleUnit = particle.entityForModifiers
			end
		end
	end

	if particle.name == "furion_sprout" then
		if particle.entityForModifiers ~= nil and Entity.IsSameTeam(Heroes.GetLocal(), particle.entityForModifiers) then
			Pugna.InvokerKSparticleProcess[1][1] = particle.index
			Pugna.InvokerKSparticleProcess[1][2] = particle.name
			Pugna.InvokerKSparticleProcess[1][3] = GameRules.GetGameTime()
			Pugna.InvokerKSparticleProcess[1][4] = particle.entityForModifiers
		end
	end

	if particle.name == "rattletrap_cog_deploy" then
		if particle.entity ~= nil and Entity.IsSameTeam(Heroes.GetLocal(), particle.entity) then
			Pugna.InvokerKSparticleProcess[1][1] = particle.index
			Pugna.InvokerKSparticleProcess[1][2] = particle.name
			Pugna.InvokerKSparticleProcess[1][3] = GameRules.GetGameTime()
			Pugna.InvokerKSparticleProcess[1][4] = particle.entity
			Pugna.InvokerKSparticleProcess[1][5] = Entity.GetAbsOrigin(particle.entity)
		end
	end

	if particle.name == "disruptor_glimpse_targetend" then
		Pugna.GlimpseParticleIndex = particle.index
		Pugna.GlimpseParticleTime = GameRules.GetGameTime()
	end

	if particle.name == "disruptor_glimpse_targetstart" then
		Pugna.GlimpseParticleIndexStart = particle.index
	end
	
end

function Pugna.OnParticleUpdate(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	if particle.position:__tostring() == Vector(1.0, 1.0, 1.0):__tostring() then return end
	if particle.position:__tostring() == Vector(0.0, 0.0, 0.0):__tostring() then return end
	if particle.position:Length() < 75 then return end

	if particle.index  == Pugna.TPParticleIndex then
		if particle.controlPoint == 0 then
			Pugna.TPParticlePosition = particle.position
		end
	end

	if particle.index  == Pugna.InvokerKSparticleProcess[1][1] then
		if particle.position:__tostring() ~= Vector(0.0, 150.0, 0.0):__tostring() then
			Pugna.InvokerKSparticleProcess[1][5] = particle.position
		end
	end

	if particle.index  == Pugna.GlimpseParticleIndex then
		if particle.position:Length2D() > 100 then
			Pugna.GlimpseParticlePosition = particle.position
		end
	end

end

function Pugna.OnParticleUpdateEntity(particle)

	if not particle then return end

	if not Heroes.GetLocal() then return end	

	if not particle.position then return end
	if particle.controlPoint > 0 then return end

	if particle.index  == Pugna.GlimpseParticleIndexStart then
		if particle.entity ~= nil and not Entity.IsSameTeam(Heroes.GetLocal(), particle.entity) then
			if particle.position:__tostring() ~= Vector(0.0, 0.0, 0.0):__tostring() then
				Pugna.GlimpseParticlePositionStart = particle.position
				Pugna.GlimpseParticleUnit = particle.entity
			end
		end
	end

end


function Pugna.OnLinearProjectileCreate(projectile)
	
	if not projectile or not projectile.source then return end
	
	if projectile.name ~= "puck_illusory_orb" then return end
	
	Pugna.PuckOrbHitSim = {{projectile.origin, projectile.velocity}}

	
end

function Pugna.OnParticleDestroy(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	if particle.index  == Pugna.TPParticleIndex then
		Pugna.TPParticlePosition = Vector()
		Pugna.TPParticleTime = 0
		Pugna.TPParticleUnit = nil
	end

end


local SkipTick = os.clock()

function Pugna.utilityRoundNumber(number, digits)

	if not number then return end

  	local mult = 10^(digits or 0)
  	return math.floor(number * mult + 0.5) / mult

end

function Pugna.utilityGetTableLength(table)

	if not table then return 0 end
	if next(table) == nil then return 0 end

	local count = 0
	for i, v in pairs(table) do
		count = count + 1
	end

	return count

end

function Pugna.utilityIsInTable(table, arg)

	if not table then return false end
	if not arg then return false end
	if next(table) == nil then return false end

	for i, v in pairs(table) do
		if i == arg then
			return true
		end
		if type(v) ~= 'table' and v == arg then
			return true
		end
	end

	return false

end

-- utility functions
function Pugna.heroSupported(myHero)

	if not myHero then return end
	local supportedHeroList = Pugna.heroList

	for _, heroName in pairs(supportedHeroList) do
		if heroName == NPC.GetUnitName(myHero) then
			return true
		end
	end
	return false
end

function Pugna.setOrderItem(printed)

	Pugna.ItemCastOrder = {
        	{Menu.GetValue(Pugna.optionItemVeil), "item_veil_of_discord", "position"},
        	{Menu.GetValue(Pugna.optionItemHex), "item_sheepstick", "target"},
        	{Menu.GetValue(Pugna.optionItemBlood), "item_bloodthorn", "target"},
        	{Menu.GetValue(Pugna.optionItemeBlade), "item_ethereal_blade", "target"},
        	{Menu.GetValue(Pugna.optionItemOrchid),"item_orchid", "target"},
        	{Menu.GetValue(Pugna.optionItemAtos),"item_rod_of_atos", "target"},
		{Menu.GetValue(Pugna.optionItemAbyssal),"item_abyssal_blade", "target"},
		{Menu.GetValue(Pugna.optionItemHalberd),"item_heavens_halberd", "target"},
		{Menu.GetValue(Pugna.optionItemShivas),"item_shivas_guard", "no target"},
		{Menu.GetValue(Pugna.optionItemDagon),"item_dagon", "target"},
		{Menu.GetValue(Pugna.optionItemDagon),"item_dagon_2", "target"},
		{Menu.GetValue(Pugna.optionItemDagon),"item_dagon_3", "target"},
		{Menu.GetValue(Pugna.optionItemDagon),"item_dagon_4", "target"},
		{Menu.GetValue(Pugna.optionItemDagon),"item_dagon_5", "target"},
		{Menu.GetValue(Pugna.optionItemUrn),"item_urn_of_shadows", "target"},
		{Menu.GetValue(Pugna.optionItemMedallion),"item_medallion_of_courage", "target"},
		{Menu.GetValue(Pugna.optionItemCrest),"item_solar_crest", "target"},
		{Menu.GetValue(Pugna.optionItemDiffusal),"item_diffusal_blade", "target"},
		{Menu.GetValue(Pugna.optionItemSpirit),"item_spirit_vessel", "target"},
		{Menu.GetValue(Pugna.optionItemNull),"item_nullifier", "target"},
    				}

    	table.sort(Pugna.ItemCastOrder, function(a, b)
        	return a[1] > b[1]
    	end)
	Log.Write(".....Item Cast Order....")
	local printed = false
		if not printed then
			for k,v in ipairs(Pugna.ItemCastOrder) do
			Log.Write(v[1]..':'..v[2])
			printed = true
			end
		end
end	

function Pugna.setOrderLinkens(printed)
	
	Pugna.LinkensBreakerItemOrder = {
        	{Menu.GetValue(Pugna.optionLinkensForce), "item_force_staff"},
        	{Menu.GetValue(Pugna.optionLinkensEul), "item_cyclone"},
        	{Menu.GetValue(Pugna.optionLinkensHalberd), "item_heavens_halberd"},
        	{Menu.GetValue(Pugna.optionLinkensHex), "item_sheepstick"},
        	{Menu.GetValue(Pugna.optionLinkensBlood),"item_bloodthorn"},
        	{Menu.GetValue(Pugna.optionLinkensOrchid),"item_orchid"},
		{Menu.GetValue(Pugna.optionLinkensDiffusal),"item_diffusal_blade", "target"},
		{Menu.GetValue(Pugna.optionLinkensPike),"item_hurricane_pike"}
    				}

    	table.sort(Pugna.LinkensBreakerItemOrder, function(a, b)
        	return a[1] > b[1]
    	end)
	Log.Write(".....Linkens Breaker Priorization Order....")
	local printed = false
		if not printed then
			for k,v in ipairs(Pugna.LinkensBreakerItemOrder) do
			Log.Write(v[1]..':'..v[2])
			printed = true
			end
		end			
	
end
		
function Pugna.OnMenuOptionChange(option, old, new)

    	if option == Pugna.optionItemVeil or
		option == Pugna.optionItemHex or
		option == Pugna.optionItemBlood or
		option == Pugna.optionItemeBlade or 
		option == Pugna.optionItemOrchid or 
		option == Pugna.optionItemAtos or 
		option == Pugna.optionItemAbyssal or 
		option == Pugna.optionItemHalberd or 
		option == Pugna.optionItemShivas or 
		option == Pugna.optionItemDagon or 
		option == Pugna.optionItemUrn or
		option == Pugna.optionItemManta or
		option == Pugna.optionItemMjollnir or
		option == Pugna.optionItemMedallion or
		option == Pugna.optionItemCrest or
		option == Pugna.optionItemDiffusal or
		option == Pugna.optionItemSpirit or
		option == Pugna.optionItemNull then
			Pugna.setOrderItem(false)
	end
	
	if option == Pugna.invokerPanelSizeOption then
		Pugna.invokerPanelInit()
    	end

	if option == Pugna.autododgerOptionTable[1] or 
		option == Pugna.autododgerOptionTable[2] or
		option == Pugna.autododgerOptionTable[3] or
		option == Pugna.autododgerOptionTable[4] or
		option == Pugna.autododgerOptionTable[5] or
		option == Pugna.autododgerOptionTable[6] or
		option == Pugna.autododgerOptionTable[7] then
		Pugna.autododgerReadyTable = {}
	end

end

function Pugna.targetChecker(genericEnemyEntity)

	local myHero = Heroes.GetLocal()
		if not myHero then return end

	if genericEnemyEntity and not Entity.IsDormant(genericEnemyEntity) and not NPC.IsIllusion(genericEnemyEntity) and Entity.GetHealth(genericEnemyEntity) > 0 then

		if Menu.IsEnabled(Pugna.optionTargetCheckAM) then
			if NPC.GetUnitName(genericEnemyEntity) == "npc_dota_hero_antimage" and NPC.HasItem(genericEnemyEntity, "item_ultimate_scepter", true) and NPC.HasModifier(genericEnemyEntity, "modifier_antimage_spell_shield") and Ability.IsReady(NPC.GetAbility(genericEnemyEntity, "antimage_spell_shield")) then
				return
			end
		end
		if Menu.IsEnabled(Pugna.optionTargetCheckLotus) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_item_lotus_orb_active") then
				return
			end
		end
		if Menu.IsEnabled(Pugna.optionTargetCheckBlademail) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_item_blade_mail_reflect") and Entity.GetHealth(Heroes.GetLocal()) <= 0.25 * Entity.GetMaxHealth(Heroes.GetLocal()) then
				return
			end
		end
		if Menu.IsEnabled(Pugna.optionTargetCheckNyx) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_nyx_assassin_spiked_carapace") then
				return
			end
		end
		if Menu.IsEnabled(Pugna.optionTargetCheckUrsa) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_ursa_enrage") then
				return
			end
		end
		if Menu.IsEnabled(Pugna.optionTargetCheckAbbadon) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_abaddon_borrowed_time") then
				return
			end
		end
		if Menu.IsEnabled(Pugna.optionTargetCheckDazzle) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_dazzle_shallow_grave") and NPC.GetUnitName(myHero) ~= "npc_dota_hero_axe" then
				return
			end
		end
		if NPC.HasModifier(genericEnemyEntity, "modifier_skeleton_king_reincarnation_scepter_active") then
			return
		end
		if NPC.HasModifier(genericEnemyEntity, "modifier_winter_wyvern_winters_curse") then
			return
		end

	return genericEnemyEntity
	end	
end

function Pugna.makeDelay(sec)

	Pugna.delay = sec + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
	Pugna.lastTick = os.clock()

end

function Pugna.noItemCastFor(sec)

	Pugna.itemDelay = sec
	Pugna.lastItemTick = os.clock()

end

function Pugna.SleepReady(sleep)

	if (os.clock() - Pugna.lastTick) >= sleep then
		return true
	end
	return false

end

function Pugna.ItemSleepReady(sleep)

	if (os.clock() - Pugna.lastItemCast) >= sleep then
		return true
	end
	return false

end

function Pugna.GetAvgLatency()

	local AVGlatency = NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2
	return AVGlatency

end

function Pugna.CastAnimationDelay(ability)

	if not ability then return end

	local abilityAnimation = Ability.GetCastPoint(ability) + Pugna.GetAvgLatency()

	return abilityAnimation

end
	
function Pugna.castLinearPrediction(myHero, enemy, adjustmentVariable)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy):GetVectors()
		enemyRotation:SetZ(0)
    	local enemyOrigin = Entity.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)


	local cosGamma = (Entity.GetAbsOrigin(myHero) - enemyOrigin):Dot2D(enemyRotation:Scaled(100)) / ((Entity.GetAbsOrigin(myHero) - enemyOrigin):Length2D() * enemyRotation:Scaled(100):Length2D())

		if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin
			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(Pugna.GetMoveSpeed(enemy) * adjustmentVariable * (1 - cosGamma)))
			end
		end
end

function Pugna.castPrediction(myHero, enemy, adjustmentVariable)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy):GetVectors()
		enemyRotation:SetZ(0)
    	local enemyOrigin = Entity.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)

	if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin
			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(Pugna.GetMoveSpeed(enemy) * adjustmentVariable))
			end
	end
end

function Pugna.isEnemyTurning(enemy)

	if enemy == nil then return true end
	if not NPC.IsRunning(enemy) then return true end
	if NPC.IsTurning(enemy) then return true else return false end
	--local rotationSpeed = Entity.GetAngVelocity(enemy):Length2D()
	
	if NPC.IsRunning(enemy) then
		table.insert(Pugna.rotationTable, rotationSpeed)
			if #Pugna.rotationTable > (Menu.GetValue(Pugna.optionKillStealInvokerTurn) + 1) then
				table.remove(Pugna.rotationTable, 1)
			end
	end
	
	if #Pugna.rotationTable < Menu.GetValue(Pugna.optionKillStealInvokerTurn) then 
		return true
	else
		local rotationSpeedCounter = 0
		i = 1
		repeat
			rotationSpeedCounter = rotationSpeedCounter + Pugna.rotationTable[#Pugna.rotationTable + 1 - i]
			i = i + 1
		until i > Menu.GetValue(Pugna.optionKillStealInvokerTurn)

		if rotationSpeedCounter / Menu.GetValue(Pugna.optionKillStealInvokerTurn) <= 10 then
			return false
		else
			return true
		end
	end

end

function Pugna.GetMoveSpeed(enemy)

	if not enemy then return end

	local base_speed = NPC.GetBaseSpeed(enemy)
	local bonus_speed = NPC.GetMoveSpeed(enemy) - NPC.GetBaseSpeed(enemy)
	local modifierHex
    	local modSheep = NPC.GetModifier(enemy, "modifier_sheepstick_debuff")
    	local modLionVoodoo = NPC.GetModifier(enemy, "modifier_lion_voodoo")
    	local modShamanVoodoo = NPC.GetModifier(enemy, "modifier_shadow_shaman_voodoo")

	if modSheep then
		modifierHex = modSheep
	end
	if modLionVoodoo then
		modifierHex = modLionVoodoo
	end
	if modShamanVoodoo then
		modifierHex = modShamanVoodoo
	end

	if modifierHex then
		if math.max(Modifier.GetDieTime(modifierHex) - GameRules.GetGameTime(), 0) > 0 then
			return 140 + bonus_speed
		end
	end

    	if NPC.HasModifier(enemy, "modifier_invoker_ice_wall_slow_debuff") then 
		return 100 
	end

	if NPC.HasModifier(enemy, "modifier_invoker_cold_snap_freeze") or NPC.HasModifier(enemy, "modifier_invoker_cold_snap") then
		return (base_speed + bonus_speed) * 0.5
	end

	if NPC.HasModifier(enemy, "modifier_spirit_breaker_charge_of_darkness") then
		local chargeAbility = NPC.GetAbility(enemy, "spirit_breaker_charge_of_darkness")
		if chargeAbility then
			local specialAbility = NPC.GetAbility(enemy, "special_bonus_unique_spirit_breaker_2")
			if specialAbility then
				 if Ability.GetLevel(specialAbility) < 1 then
					return Ability.GetLevel(chargeAbility) * 50 + 550
				else
					return Ability.GetLevel(chargeAbility) * 50 + 1050
				end
			end
		end
	end
			
    	return base_speed + bonus_speed
end

function Pugna.getBestPosition(unitsAround, radius)

	if not unitsAround or #unitsAround < 1 then
		return 
	end

	local countEnemies = #unitsAround

	if countEnemies == 1 then 
		return Entity.GetAbsOrigin(unitsAround[1]) 
	end

	return Pugna.getMidPoint(unitsAround)

end

function Pugna.getMidPoint(entityList)

	if not entityList then return end
	if #entityList < 1 then return end

	local pts = {}
		for i, v in ipairs(entityList) do
			if v and not Entity.IsDormant(v) then
				local pos = Entity.GetAbsOrigin(v)
				local posX = pos:GetX()
				local posY = pos:GetY()
				table.insert(pts, { x=posX, y=posY })
			end
		end
	
	local x, y, c = 0, 0, #pts

		if (pts.numChildren and pts.numChildren > 0) then c = pts.numChildren end

	for i = 1, c do

		x = x + pts[i].x
		y = y + pts[i].y

	end

	return Vector(x/c, y/c, 0)

end

function Pugna.GetMyFaction(myHero)

	if not myHero then return end
	
	local radiantFountain = Vector(-7600, -7300, 640)
	local direFountain = Vector(7800, 7250, 640)
	
	local myFountain
	if myFountain == nil then
		for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
    			if Entity.IsSameTeam(myHero, npc) and NPC.IsStructure(npc) then
    				if NPC.GetUnitName(npc) ~= nil then
        				if NPC.GetUnitName(npc) == "dota_fountain" then
						myFountain = npc
					end
				end
			end
		end
	end

	local myFaction
	if myFaction == nil and myFountain ~= nil then
		if NPC.IsPositionInRange(myFountain, radiantFountain, 1000, 0) then
			myFaction = "radiant"
		else myFaction = "dire"
		end
	end

	return myFaction

end

function Pugna.GetMyFountainPos(myHero)

	if not myHero then return end

	local myFaction = Pugna.GetMyFaction(myHero)

	local myFountainPos
	if myFaction == "radiant" then
		myFountainPos = Vector(-7600, -7300, 640)
	else myFountainPos = Vector(7800, 7250, 640)
	end

	return myFountainPos

end

function Pugna.GetEnemyFountainPos(myHero)

	if not myHero then return end

	local myFaction = Pugna.GetMyFaction(myHero)

	local enemyFountainPos
	if myFaction == "radiant" then
		enemyFountainPos = Vector(7800, 7250, 640)
	else enemyFountainPos = Vector(-7600, -7300, 640)
	end

	return enemyFountainPos

end

function Pugna.IsCreepAncient(npc)

	if not npc then return false end

	ancientNameList = { 
		"npc_dota_neutral_black_drake",
    		"npc_dota_neutral_black_dragon",
    		"npc_dota_neutral_blue_dragonspawn_sorcerer",
    		"npc_dota_neutral_blue_dragonspawn_overseer",
    		"npc_dota_neutral_granite_golem",
    		"npc_dota_neutral_elder_jungle_stalker",
    		"npc_dota_neutral_prowler_acolyte",
    		"npc_dota_neutral_prowler_shaman",
    		"npc_dota_neutral_rock_golem",
    		"npc_dota_neutral_small_thunder_lizard",
    		"npc_dota_neutral_jungle_stalker",
    		"npc_dota_neutral_big_thunder_lizard",
    		"npc_dota_roshan" }

	for _, creepName in ipairs(ancientNameList) do
		if creepName and NPC.GetUnitName(npc) ~= nil then
			if NPC.GetUnitName(npc) == creepName then
				return true
			end
		end
	end

	return false

end

function Pugna.IsInAbilityPhase(myHero)

	if not myHero then return false end

	local myAbilities = {}

	for i= 0, 10 do
		local ability = NPC.GetAbilityByIndex(myHero, i)
		if ability and Entity.IsAbility(ability) and Ability.GetLevel(ability) > 0 then
			table.insert(myAbilities, ability)
		end
	end

	if #myAbilities < 1 then return false end

	for _, v in ipairs(myAbilities) do
		if v then
			if Ability.IsInAbilityPhase(v) then
				return true
			end
		end
	end

	return false

end


function Pugna.OrbWalker(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	if NPC.IsChannellingAbility(myHero) then return end
	if Pugna.isHeroChannelling(myHero) == true then return end
	if Pugna.heroCanCastItems(myHero) == false then return end
	if Pugna.IsInAbilityPhase(myHero) == true then return end

	local myMana = NPC.GetMana(myHero)

	local attackRange = NPC.GetAttackRange(myHero)

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)
	local attackTime = NPC.GetAttackTime(myHero)
	local movementSpeed = NPC.GetMoveSpeed(myHero)

	local attackPoint
	local attackBackSwing
	for i, v in pairs(Pugna.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			attackPoint = v[1] / (1 + (increasedAS/100))
			attackBackSwing = v[2] / (1 + (increasedAS/100))
			break
		end
	end

	local idleTime = attackTime - attackPoint - attackBackSwing

	local turnTime180degrees = (0.03 * math.pi) / NPC.GetTurnRate(myHero)

	local orbWalkSkill
	for i, v in pairs(Pugna.orbAttackTable) do
		if i == NPC.GetUnitName(myHero) then
			orbWalkSkill = NPC.GetAbility(myHero, v)
			break
		end
	end

	if orbWalkSkill then
		if Ability.GetName(orbWalkSkill) == "viper_poison_attack" then
			if NPC.HasModifier(enemy, "modifier_viper_poison_attack_slow") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_viper_poison_attack_slow"))
				if dieTime - GameRules.GetGameTime() > 1.0 then
					orbWalkSkill = nil
				end
			end
		end
	end

	if Entity.IsSameTeam(myHero, enemy) then
		orbWalkSkill = nil
	end

	if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		orbWalkSkill = nil
	end

	if NPC.IsRanged(myHero) then
		if Pugna.AttackProjectileCreate > 0 then
			if os.clock() > Pugna.AttackAnimationCreate and os.clock() < Pugna.AttackProjectileCreate + attackBackSwing + idleTime then
				Pugna.InAttackBackswing = true
			else
				Pugna.InAttackBackswing = false
			end
		end
	else
		if Pugna.AttackParticleCreate > 0 then
			if NPC.HasItem(myHero, "item_echo_sabre", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) < (attackPoint / 1.49) + 0.15 then
					Pugna.InAttackBackswing = false
				else
					if os.clock() > Pugna.AttackAnimationCreate and os.clock() < Pugna.AttackParticleCreate + attackBackSwing + idleTime then
						Pugna.InAttackBackswing = true
					else
						Pugna.InAttackBackswing = false
					end
				end
			else
				if os.clock() > Pugna.AttackAnimationCreate and os.clock() < Pugna.AttackParticleCreate + attackBackSwing + idleTime then
					Pugna.InAttackBackswing = true
				else
					Pugna.InAttackBackswing = false
				end
			end
		end
	end

	if os.clock() > Pugna.AttackAnimationCreate and os.clock() < Pugna.AttackParticleCreate then
		Pugna.InAttackBackswing = false
	end

	if os.clock() > Pugna.AttackAnimationCreate and os.clock() < Pugna.AttackProjectileCreate then
		Pugna.InAttackBackswing = false
	end

	local breakPoint
		if NPC.IsRanged(myHero) then
			breakPoint = attackRange * (Menu.GetValue(Pugna.optionOrbwalkDistance) / 100)
		else
			breakPoint = attackRange
		end

	local moveDistance = NPC.GetMoveSpeed(myHero) * (attackBackSwing + idleTime - NPC.GetTimeToFace(myHero, enemy)) * (1 - (Menu.GetValue(Pugna.optionOrbwalkOffset) / 100))
		if NPC.IsRanged(myHero) then
			if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() > breakPoint and (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() <= breakPoint + moveDistance then
				moveDistance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - breakPoint
			end
		end

	local kiteDistance = 0
		if (2 * turnTime180degrees) < (attackBackSwing + idleTime) * (1 - (Menu.GetValue(Pugna.optionOrbwalkOffset) / 100)) then
			kiteDistance = ((attackBackSwing + idleTime) * (1 - (Menu.GetValue(Pugna.optionOrbwalkOffset) / 100)) - (2 * turnTime180degrees)) * NPC.GetMoveSpeed(myHero)
		end

	local styleSelector = 0
		if Menu.GetValue(Pugna.optionOrbwalkStyle) == 0 then
			styleSelector = 1
		else
			if Menu.GetValue(Pugna.optionOrbwalkMouseStyle) == 1 then
				styleSelector = 2
			else
				if NPC.IsRanged(myHero) then			
					styleSelector = 2
				else
					styleSelector = 1
				end
			end
		end
	
	if styleSelector < 2 then
		if not Pugna.InAttackBackswing then
			if orbWalkSkill and Ability.IsCastable(orbWalkSkill, myMana) then
				if os.clock() - Pugna.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastTarget(orbWalkSkill, enemy)
					Pugna.OrbwalkerDelay = os.clock()
					return
				end
			else
				if os.clock() - Pugna.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and os.clock() - Pugna.AttackAnimationCreate > attackPoint + 0.1 then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					Pugna.OrbwalkerDelay = os.clock()
					return
				end
			end
		else
			if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() > breakPoint then
				if os.clock() - Pugna.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					if moveDistance > 50 then
						local targetVector = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(moveDistance)
						NPC.MoveTo(myHero, targetVector, false, false)
						Pugna.OrbwalkerDelay = os.clock()
						return
					end
				end
	
			end
			if Menu.IsEnabled(Pugna.optionOrbwalkKiting) then
				if NPC.IsRanged(myHero) then
					if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() < breakPoint - 50 then
						if os.clock() - Pugna.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
							if kiteDistance > 50 then
								local targetVector = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(kiteDistance)
								NPC.MoveTo(myHero, targetVector, false, false)
								Pugna.OrbwalkerDelay = os.clock()
								return
							end
						end
					end
				end
			end
		end
	else
		local mousePos = Input.GetWorldCursorPos()
		local breakPoint2
			if NPC.IsRanged(myHero) then
				breakPoint2 = attackRange * (Menu.GetValue(Pugna.optionOrbwalkDistanceMouse) / 100)
			else
				breakPoint2 = attackRange
			end
		local moveDistance2 = NPC.GetMoveSpeed(myHero) * (attackBackSwing + idleTime - NPC.GetTimeToFace(myHero, enemy) - Pugna.TimeToFacePosition(myHero, mousePos)) * (1 - (Menu.GetValue(Pugna.optionOrbwalkOffset) / 100))
		
		if not Pugna.InAttackBackswing then
			if orbWalkSkill and Ability.IsCastable(orbWalkSkill, myMana) then
				if os.clock() - Pugna.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastTarget(orbWalkSkill, enemy)
					Pugna.OrbwalkerDelay = os.clock()
					return
				end
			else
				if os.clock() - Pugna.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and os.clock() - Pugna.AttackAnimationCreate > attackPoint + 0.1 then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					Pugna.OrbwalkerDelay = os.clock()
					return
				end
			end
		else
			if os.clock() - Pugna.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				local myDisToMouse = (Entity.GetAbsOrigin(myHero) - mousePos):Length2D()
				if moveDistance2 > 50 and myDisToMouse > Menu.GetValue(Pugna.optionOrbwalkMouseHold) then
					local targetVector = Entity.GetAbsOrigin(myHero) + (mousePos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(moveDistance2)
					if not NPC.IsPositionInRange(enemy, targetVector, breakPoint2, 0) then
						NPC.MoveTo(myHero, targetVector, false, false)
						Pugna.OrbwalkerDelay = os.clock()
						return
					end
				end
			end
		end
	end

end

function Pugna.TimeToFacePosition(myHero, pos)

	if not myHero then return 0 end
	if not pos then return 0 end

	local myPos = Entity.GetAbsOrigin(myHero)
	local myRotation = Entity.GetRotation(myHero):GetForward():Normalized()

	local baseVec = (pos - myPos):Normalized()

	local tempProcessing = math.min(baseVec:Dot2D(myRotation) / (baseVec:Length2D() * myRotation:Length2D()), 1)	

	local checkAngleRad = math.acos(tempProcessing)
	local checkAngle = (180 / math.pi) * checkAngleRad

	local myTurnRate = NPC.GetTurnRate(myHero)

	local turnTime = Pugna.utilityRoundNumber(((0.033 * math.pi / myTurnRate) / 180) * checkAngle, 3)

	return turntime or 0

end

function Pugna.GetLongestCooldown(myHero, skill1, skill2, skill3, skill4, skill5)

	if not myHero then return end

	local skill1 = skill1
	local skill2 = skill2
	local skill3 = skill3
	local skill4 = skill4
	local skill5 = skill5


	local tempTable = {}

	if skill1 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill1)))
	end
	if skill2 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill2)))
	end
	if skill3 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill3)))
	end
	if skill4 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill4)))
	end
	if skill5 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill5)))
	end

	table.sort(tempTable, function(a, b)
        	return a > b
    			end)

	return tempTable[1]

end

function Pugna.GenericLanePusher(npc)

	if not npc or (npc and not Entity.IsAlive(npc)) then return end

	local myFaction = Pugna.GetMyFaction(npc)
	local myFountainPos = Pugna.GetMyFountainPos(npc)
	local enemyFountainPos = Pugna.GetEnemyFountainPos(npc)

	local leftCornerPos = Vector(-5750, 6050, 384)
	local rightCornerPos = Vector(6000, -5800, 384)
	local midPos = Vector(-600, -300, 128)

	local radiantTop2 = Vector(-6150, -800, 384)
	local radiantBot2 = Vector(-800, -6250, 384)
	local radiantMid2 = Vector(-2800, -2250, 256)
	
	local direTop2 = Vector(800, 6000, 384)
	local direBot2 = Vector(6200, 400, 384)
	local direMid2 = Vector(2800, 2100, 256)


	local myBotTower2
		if myFaction == "radiant"
			then myBotTower2 = radiantBot2
		else myBotTower2 = direBot2
		end

	local myTopTower2
		if myFaction == "radiant"
			then myTopTower2 = radiantTop2
		else myTopTower2 = direTop2
		end

	local myMidTower2
		if myFaction == "radiant"
			then myMidTower2 = radiantMid2
		else myMidTower2 = direMid2
		end


	local myPos = Entity.GetAbsOrigin(npc)

	local homeSide
	if myPos:__sub(myFountainPos):Length2D() < myPos:__sub(enemyFountainPos):Length2D() then
		homeSide = true
	else homeSide = false
	end
	
	if not homeSide then
		return enemyFountainPos
	end

	if homeSide then
		if myPos:__sub(leftCornerPos):Length2D() <= 800 then
			return enemyFountainPos
		elseif myPos:__sub(rightCornerPos):Length2D() <= 800 then
			return enemyFountainPos
		elseif myPos:__sub(midPos):Length2D() <= 800 then
			return enemyFountainPos
		end
	end

	if homeSide then
		if myPos:__sub(leftCornerPos):Length2D() > 800 and myPos:__sub(rightCornerPos):Length2D() > 800 and myPos:__sub(midPos):Length2D() > 800 then
			
			if myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(midPos):Length2D() then
				return leftCornerPos
			elseif myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myTopTower2):Length2D() < myPos:__sub(midPos):Length2D() and myPos:__sub(myMidTower2):Length2D() > myPos:__sub(myTopTower2):Length2D() then
				return leftCornerPos
			elseif myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(midPos):Length2D() then
				return rightCornerPos
			elseif myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(myBotTower2):Length2D() < myPos:__sub(midPos):Length2D() and myPos:__sub(myMidTower2):Length2D() > myPos:__sub(myBotTower2):Length2D() then
				return rightCornerPos
			elseif myPos:__sub(midPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(midPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myMidTower2):Length2D() < myPos:__sub(myTopTower2):Length2D() then
				return enemyFountainPos
			elseif myPos:__sub(midPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(midPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myMidTower2):Length2D() < myPos:__sub(myBotTower2):Length2D() then
				return enemyFountainPos
			else return enemyFountainPos
			end
		end
	end
end

function Pugna.ForceBlink(myHero, enemy, range)

	if not myHero then return end
	
	local blink = NPC.GetItem(myHero, "item_blink", true)
		if not blink then return end
		if blink and not Ability.IsReady(blink) then return end

	if not enemy or (enemy and not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), range, 0)) then
		if Menu.IsKeyDown(Pugna.optionComboKey) then
			if NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), 1100, 0) then
				Ability.CastPosition(blink, Input.GetWorldCursorPos())
				return
			else
				if Pugna.SleepReady(0.1) then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Input.GetWorldCursorPos(), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
					Pugna.lastTick = os.clock()
					return
				end
			end	
		end
	end
end

function Pugna:WorldToMiniMap(pos, screenWidth, screenHeight)
	local screenH = screenHeight
	local screenW = screenWidth 
	local MapLeft = -8000
	local MapTop = 7350
	local MapRight = 7500
	local MapBottom = -7200
	local mapWidth = math.abs(MapLeft - MapRight)
	local mapHeight = math.abs(MapBottom - MapTop)
	

	local x = pos:GetX() - MapLeft
	local y = pos:GetY() - MapBottom

	local dx, dy, px, py
	if self.Round(screenW / screenH, 1) >= 1.7 then

		dx = 272 / 1920 * screenW
		dy = 261 / 1080 * screenH
		px = 11 / 1920 * screenW
		py = 11 / 1080 * screenH
	elseif self.Round(screenW / screenH, 1) >= 1.5 then

		dx = 267 / 1680 * screenW
		dy = 252 / 1050 * screenH
		px = 10 / 1680 * screenW
		py = 11 / 1050 * screenH
	else
		dx = 255 / 1280 * screenW
		dy = 229 / 1024 * screenH
		px = 6 / 1280 * screenW
		py = 9 / 1024 * screenH
	end
	local minimapMapScaleX = dx / mapWidth
	local minimapMapScaleY = dy / mapHeight

	local scaledX = math.min(math.max(x * minimapMapScaleX, 0), dx)
	local scaledY = math.min(math.max(y * minimapMapScaleY, 0), dy)

	local screenX = px + scaledX
	local screenY = screenH - scaledY - py

	return Vector(math.floor(screenX - 20 + Menu.GetValue(Pugna.optionWorldToMinimapOffsetX)), math.floor(screenY - 12 + Menu.GetValue(Pugna.optionWorldToMinimapOffsetY)), 0)
end

function Pugna.Round(num, numDecimalPlaces)
	local mult = 10^(numDecimalPlaces or 0)
	return math.floor(num * mult + 0.5) / mult
end

function Pugna.TargetDisableTimer(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_item_rod_of_atos_debuff",
		"modifier_eul_cyclone",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption"
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				return Modifier.GetCreationTime(searchMod) + 4
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				return Modifier.GetCreationTime(searchMod) + (3.5 + Pugna.GetTeammateAbilityLevel(myHero, "faceless_void_chronosphere") * 0.5)
			else
				return Modifier.GetDieTime(searchMod)
			end
		else
			return 0
		end
	else
		return 0
	end

end

function Pugna.GetTeammateAbilityLevel(myHero, ability)

	if not myHero then return end
	if not ability then return 0 end

	for _, teamMate in ipairs(Entity.GetHeroesInRadius(myHero, 99999, Enum.TeamType.TEAM_FRIEND)) do
		if NPC.HasAbility(teamMate, ability) then
			if NPC.GetAbility(teamMate, ability) then
				return Ability.GetLevel(NPC.GetAbility(teamMate, ability))
			end
		end
	end
	return 0

end

function Pugna.TargetIsInvulnarable(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local curTime = GameRules.GetGameTime()

	local invuList = {
		"modifier_eul_cyclone",
		"modifier_invoker_tornado",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption"
			}
	
	local searchMod
	for _, modifier in ipairs(invuList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			return Modifier.GetDieTime(searchMod)
		else
			return 0
		end
	else
		return 0
	end

end


function Pugna.TargetIndicator(myHero)

	if not myHero then return end

	local curtime = GameRules.GetGameTime()	

	if Menu.GetValue(Pugna.optionLockTargetParticle) < 2 then
		if Pugna.LockedTarget ~= nil then
			if curtime > Pugna.particleNextTime then
				if Pugna.currentParticle > 0 then
					Particle.Destroy(Pugna.currentParticle)
					Pugna.currentParticle = 0
				end
	
				if Menu.GetValue(Pugna.optionLockTargetParticle) == 0 then
					local sparkParticle = Particle.Create("particles/items_fx/aegis_resspawn_flash.vpcf")
					Pugna.currentParticle = sparkParticle
			
					Particle.SetControlPoint(sparkParticle, 0, Entity.GetAbsOrigin(Pugna.LockedTarget))
				else
					local bloodParticle = Particle.Create("particles/items2_fx/soul_ring_blood.vpcf")
					Pugna.currentParticle = bloodParticle
					Particle.SetControlPoint(bloodParticle, 0, Entity.GetAbsOrigin(Pugna.LockedTarget))
				end

	      		Pugna.particleNextTime = curtime + 0.35
			end
		end
	else
		if (not Pugna.LockedTarget or Pugna.LockedTarget ~= Pugna.currentParticleTarget) and Pugna.currentParticle > 0 then
			Particle.Destroy(Pugna.currentParticle)			
			Pugna.currentParticle = 0
			Pugna.currentParticleTarget = Pugna.LockedTarget
		else
			if Pugna.currentParticle == 0 and Pugna.LockedTarget then
				local towerParticle = Particle.Create("particles/ui_mouseactions/range_finder_tower_aoe.vpcf", Enum.ParticleAttachment.PATTACH_INVALID, Pugna.LockedTarget)	
				Pugna.currentParticle = towerParticle
				Pugna.currentParticleTarget = Pugna.LockedTarget			
			end
			if Pugna.currentParticle > 0 then
				Particle.SetControlPoint(Pugna.currentParticle, 2, Entity.GetOrigin(myHero))
				Particle.SetControlPoint(Pugna.currentParticle, 6, Vector(1, 0, 0))
				Particle.SetControlPoint(Pugna.currentParticle, 7, Entity.GetOrigin(Pugna.currentParticleTarget))
			end
		end
	end

end



function Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)

	if not myHero then return end
	if not unit then return end

	local angle = Entity.GetRotation(unit)

	local direction = angle:GetForward()
    		direction:SetZ(0)

    	local origin = Entity.GetAbsOrigin(unit)

	if radius == 0 then
		radius = 100
	end

	local alliesAround = Entity.GetHeroesInRadius(unit, radius + castrange, Enum.TeamType.TEAM_ENEMY)
		if #alliesAround < 1 then return end

	local pointsNum = math.floor(castrange/50) + 1
	
	local targetAlly = nil
	local facing = 99999
	local lowest = 99999
	for i, v in ipairs(alliesAround) do
		if v and Entity.IsHero(v) and Entity.IsAlive(v) and v ~= myHero then
			if NPC.IsEntityInRange(unit, v, radius + castrange) and NPC.IsEntityInRange(myHero, v, 885) then
				if castrange > 1 then
					if NPC.GetTimeToFace(unit, v) < facing then
						facing = NPC.GetTimeToFace(unit, v)
						targetAlly = v
					end
				else
					if Entity.GetHealth(v) < lowest then
						lowest = Entity.GetHealth(v)
						targetAlly = v
					end
				end	
			end
		end
	end	

	return targetAlly

end

function Pugna.dodgerEmberSkillsChecker(myHero, skillName)

	if not myHero then return false end
	if not skillName then return false end

	if skillName == "ember_spirit_sleight_of_fist" then
		local effectRange = Ability.GetLevel(NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")) * 100 + 150
		for i = 0, math.floor(700 / effectRange) do
			if #NPCs.InRadius(Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange), effectRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
				return true
			end
		end
	end

	if skillName == "ember_spirit_activate_fire_remnant" then
		if NPC.HasModifier(myHero, "modifier_ember_spirit_fire_remnant_timer") then
			return true
		end
	end

	return false

end

function Pugna.saveIt(info)

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Entity.IsAlive(myHero) then return end
	
	if not info then return end

	if not Menu.IsEnabled(Pugna.optionDefensiveItemsSaver) then return end

	local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local lotus = NPC.GetItem(myHero, "item_lotus_orb", true)
	local myMana = NPC.GetMana(myHero)

	local itemCheck = glimmer or lotus or nil
		if not itemCheck then return end

	if glimmer then
		if not Ability.IsCastable(glimmer, myMana) then
			if lotus then
				if not Ability.IsCastable(lotus, myMana) then
					return
				end
			else
				return
			end
		end
	else
		if lotus then
			if not Ability.IsCastable(lotus, myMana) then
				return
			end
		else
			return
		end
	end

	if info.target and Entity.IsHero(info.target) and Entity.IsAlive(info.target) then
		if info.lotus == 1 and NPC.IsLinkensProtected(info.target) then return end
		if info.lotus == 1 and NPC.HasModifier(info.target, "modifier_item_lotus_orb_active") then return end
		if info.style == 2 and NPC.HasState(info.target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end
		if NPC.HasModifier(info.target, "modifier_item_glimmer_cape_fade") then return end
		if NPC.HasModifier(info.target, "modifier_templar_assassin_refraction_absorb") then return end
	end

	if os.clock() - Pugna.saverTiming < 0.5 then return end

	local curTime = GameRules.GetGameTime()

	local saveObject
		if lotus then
			if Ability.IsCastable(lotus, myMana) then
				if info.lotus == 0 then
					if glimmer then
						if Ability.IsCastable(glimmer, myMana) then
							saveObject = glimmer
						else
							saveObject = nil
						end
					else
						saveObject = nil
					end
				else
					saveObject = lotus
				end
			else
				if glimmer then
					if Ability.IsCastable(glimmer, myMana) then
						saveObject = glimmer
					else
						saveObject = nil
					end
				else
					saveObject = nil
				end
			end
		else
			if glimmer then
				if Ability.IsCastable(glimmer, myMana) then
					saveObject = glimmer
				else
					saveObject = nil
				end
			else
				saveObject = nil
			end
		end
	
	if saveObject == nil then return end		

	local target = info.target

	if target and Entity.IsHero(target) and NPC.IsEntityInRange(myHero, target, 895) then
		Ability.CastTarget(saveObject, target)
		Pugna.saverTiming = os.clock()
		Pugna.lastDefItemPop = os.clock()
		return
	end

end


function Pugna.dodgerSkillAvailable(myHero)

	if not myHero then return end

	if next(Pugna.autododgerSkillReady) == nil then

		for i = 1, #Pugna.autododgerSkills do
			if NPC.HasAbility(myHero, Pugna.autododgerSkills[i][1]) then
				if Menu.IsEnabled(Pugna.dodgeEnemyHeroskillsOptionsTable[Pugna.autododgerSkills[i][1]]) then
					if Ability.GetLevel(NPC.GetAbility(myHero, Pugna.autododgerSkills[i][1])) > 0 then
						table.insert(Pugna.autododgerSkillReady, {skillname = Pugna.autododgerSkills[i][1], skillstyle = Pugna.autododgerSkills[i][2], skilltargeting = Pugna.autododgerSkills[i][3], skilloffset = Pugna.autododgerSkills[i][4] })
					end
				end
			end
		end
	end

end
				
function Pugna.dodgerSelectItemorSkill(myHero)

	if not myHero then return end

	if next(Pugna.autododgerReadyTable) == nil then

		for i = 1, #Pugna.autododgerItems do
			if Menu.GetValue(Pugna.autododgerOptionTable[i]) > 0 then
				table.insert(Pugna.autododgerReadyTable, { prio = Menu.GetValue(Pugna.autododgerOptionTable[i]), itemname = Pugna.autododgerItems[i][1], itemstyle = Pugna.autododgerItems[i][2], itemtargeting = Pugna.autododgerItems[i][3], itemoffset = Pugna.autododgerItems[i][4] })
			end
		end
	end

	table.sort(Pugna.autododgerReadyTable, function(a, b)
       		return a.prio < b.prio
    	end)

end

function Pugna.dodgerRangeOffsetter(myHero, enemy, dodgeSkillName, attackSkillName)

	if not myHero then return end

	if not dodgeSkillName and not attackSkillName then 
		return 
	end

	if dodgeSkillName == "item_blink" then 
		return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(1150)
	end

	local maxRange = 1000
		if dodgeSkillName == "morphling_waveform" then
			maxRange = 990
		elseif dodgeSkillName == "phantom_lancer_doppelwalk" then
			maxRange = 590
		elseif dodgeSkillName == "faceless_void_time_walk" then
			maxRange = 670
		elseif dodgeSkillName == "ember_spirit_sleight_of_fist" then
			maxRange = 690
		end

	local minRange = 190
		if dodgeSkillName == "morphling_waveform" or dodgeSkillName == "faceless_void_time_walk" then
			minRange = maxRange
		end


	if dodgeSkillName ~= "ember_spirit_sleight_of_fist" then
		if attackSkillName == "enigma_black_hole" or attackSkillName == "faceless_void_chronosphere" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(590)
		elseif attackSkillName == "lion_impale" or attackSkillName == "nyx_assassin_impale" or spellname == "pudge_dismember" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(350)
		elseif attackSkillName == "queenofpain_sonic_wave" or attackSkillName == "tidehunter_ravage" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(maxRange)
		else
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(minRange)
		end
	else
		local effectRange = Ability.GetLevel(NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")) * 100 + 150 - 1
		for i = 0, math.ceil(maxRange / effectRange) do
			if #NPCs.InRadius(Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange), effectRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
				return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange + 1)
			end
		end
	end

end

function Pugna.dodgerProjectileTimingAdjuster(myHero)

	if not myHero then return end

	if next(Pugna.autododgerTable) == nil then return end

	if os.clock() - Pugna.dodgerProjectileAdjustmentTick < 0.05 then return end

	for i, info in pairs(Pugna.autododgerTable) do
		if info.delay > info.castpoint then
			if info.spellname ~= "lion_finger_of_death" and info.spellname ~= "lina_laguna_blade" then
				local originPos = info.originpos
				local myHullSize = NPC.GetHullRadius(myHero)
				local projectileStart = info.casttime + info.castpoint
				local projectileSpeed = info.projectilespeed
				local timeElapsed = math.max((GameRules.GetGameTime() - projectileStart), 0)
				local projectilePos = originPos + (Entity.GetAbsOrigin(myHero) - originPos):Normalized():Scaled(timeElapsed*projectileSpeed)
				local myDisToOrigin = (Entity.GetAbsOrigin(myHero) - originPos):Length2D() - myHullSize
				local projectilDisToOrigin = (projectilePos - originPos):Length2D()
				local myDisToProjectile = (Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() 
				if projectilDisToOrigin < myDisToOrigin then
					if myDisToProjectile > 100 and timeElapsed > 0 then
						local remainingTravelTime = ((Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() - myHullSize) / projectileSpeed
						local adjustedDelay = math.max(info.projectileextradelay, 0.034)
							if info.projectileextradelay < 0 then
								adjustedDelay = info.projectileextradelay
							end
						local processImpactTime = info.castpoint + timeElapsed + remainingTravelTime - adjustedDelay
						if math.abs(info.delay - processImpactTime) > 0.015 then
							if Pugna.autododgerTable[i] ~= nil then
								Pugna.autododgerTable[i]["delay"] = processImpactTime
								Pugna.dodgerProjectileAdjustmentTick = os.clock()
							end
						end
					end
				else
					Pugna.autododgerTable[i] = nil
				end
			end
		end
	end			

end

function Pugna.dodger(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	if next(Pugna.autododgerTable) == nil then
		for i = 1, Heroes.Count() do
			local enemy = Heroes.Get(i)
			if enemy and Entity.IsHero(enemy) and not Entity.IsSameTeam(myHero, enemy) and not Entity.IsDormant(enemy) and (NPC.GetUnitName(enemy) == "npc_dota_hero_axe" or NPC.GetUnitName(enemy) == "npc_dota_hero_sand_king") and not NPC.IsIllusion(enemy) then
				if Entity.IsAlive(enemy) then
					local axe_call = NPC.GetAbility(enemy, "axe_berserkers_call")
					local call_range = 300
					if axe_call and Ability.IsInAbilityPhase(axe_call) and NPC.IsEntityInRange(myHero, enemy, call_range) then
						Pugna.autododger({time = GameRules.GetGameTime(); delay = 0.4; style = 1; source = enemy, lotus = 0, castpoint = 0.4, spellname = "axe_berserkers_call", global = 0, type = "disable"})
						break
						return
					end
					local burrowStrike = NPC.GetAbility(enemy, "sandking_burrowstrike")
					local burrowRange = 650
					local hitRange = 175
						if NPC.HasItem(enemy, "item_ultimate_scepter", true) or NPC.HasModifier(enemy, "modifier_item_ultimate_scepter_consumed") then
							burrowRange = 1300
						end
					if NPC.HasModifier(enemy, "modifier_sandking_burrowstrike") then
						if Pugna.dodgeIsTargetMe(myHero, enemy, hitRange, burrowRange) then
							Pugna.autododger({time = GameRules.GetGameTime(); delay = 0.05; style = 2; source = enemy, lotus = 1, castpoint = 0, spellname = "sandking_burrowstrike", global = 0, type = "disable"})
							break
							return
						else
							if NPC.IsEntityInRange(myHero, enemy, hitRange+burrowRange+885) then
								local targetAlly = Pugna.saverGetAllyTarget(myHero, enemy, hitRange, burrowRange)
								if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
									Pugna.saveIt({lotus = 1, target = targetAlly})
								end
							end
						end
					end
				end
			end
		end
	end

	if next(Pugna.autododgerTable) == nil then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_alchemist" then
			if NPC.HasModifier(myHero, "modifier_alchemist_unstable_concoction") then
				if Modifier.GetCreationTime(NPC.GetModifier(myHero, "modifier_alchemist_unstable_concoction")) + 5.5 - GameRules.GetGameTime() < 0.15 then
					Pugna.autododger({time = GameRules.GetGameTime(); delay = 0.15; style = 1; source = myHero, lotus = 0, castpoint = 0, spellname = "alchemist_unstable_concoction_throw", global = 0, type = "disable"})
					return
				end
			end
		end
	end

	if next(Pugna.autododgerTable) == nil then return end
	Pugna.dodgerProjectileTimingAdjuster(myHero)
	local curTime = GameRules.GetGameTime()

	if not Pugna.heroCanCastItems(myHero) then
		return
	end

	if os.clock() - Pugna.dodgeTiming < 0.5 then return end

	local dodgeInfo = Pugna.autododgerTable[1]
		local casttime = dodgeInfo.casttime
		local delay = dodgeInfo.delay
		local unit = dodgeInfo.unit
		local castpoint = dodgeInfo.castpoint
		local spellname = dodgeInfo.spellname
		local dodgeobject = dodgeInfo.dodgeobject
		local objecttargeting = dodgeInfo.objecttargeting
		local objectoffset = dodgeInfo.objectoffset

		if curTime > casttime + delay + 0.05 then
			Pugna.autododgerTable = {}
			return
		end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sniper" then
		if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
			if NPC.HasModifier(myHero, "modifier_sniper_assassinate") then
				if objecttargeting == "no target" then
					Ability.CastNoTarget(dodgeobject)
					Pugna.dodgeTiming = os.clock()
					Pugna.autododgerTable = {}
					return
				elseif objecttargeting == "position" then
					if Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
						Ability.CastPosition(dodgeobject, Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
						Pugna.dodgeTiming = os.clock()
						Pugna.autododgerTable = {}
						return
					end
				elseif objecttargeting == "target" then
					Ability.CastTarget(dodgeobject, myHero)
					Pugna.dodgeTiming = os.clock()
					Pugna.autododgerTable = {}
					return
				end
			end
		end
	else	
		if unit and not Entity.IsDormant(unit) then
			if curTime >= casttime + castpoint - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if not Ability.IsInAbilityPhase(NPC.GetAbility(unit, spellname)) and castpoint > 0 then
					if delay > castpoint then
						if Ability.SecondsSinceLastUse(NPC.GetAbility(unit, spellname)) == -1 and spellname ~= "alchemist_unstable_concoction_throw" then
							Pugna.autododgerTable = {}
							return
						else
							if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then

								if objecttargeting == "no target" then
									Ability.CastNoTarget(dodgeobject)
									Pugna.dodgeTiming = os.clock()
									Pugna.autododgerTable = {}
									return
								elseif objecttargeting == "position" then
									if Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
										Ability.CastPosition(dodgeobject, Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
										Pugna.dodgeTiming = os.clock()
										Pugna.autododgerTable = {}
										return
									end
								elseif objecttargeting == "target" then
									Ability.CastTarget(dodgeobject, myHero)
									Pugna.dodgeTiming = os.clock()
									Pugna.autododgerTable = {}
									return
								end
							end
						end
					else
						Pugna.autododgerTable = {}
						return
					end
				else
					if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						if objecttargeting == "no target" then
							Ability.CastNoTarget(dodgeobject)
							Pugna.dodgeTiming = os.clock()
							Pugna.autododgerTable = {}
							return
						elseif objecttargeting == "position" then
							if Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
								Ability.CastPosition(dodgeobject, Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
								Pugna.dodgeTiming = os.clock()
								Pugna.autododgerTable = {}
								return
							end
						elseif objecttargeting == "target" then
							Ability.CastTarget(dodgeobject, myHero)
							Pugna.dodgeTiming = os.clock()
							Pugna.autododgerTable = {}
							return
						end
					end
				end
			end
		else
			if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if objecttargeting == "no target" then
					Ability.CastNoTarget(dodgeobject)
					Pugna.dodgeTiming = os.clock()
					Pugna.autododgerTable = {}
					return
				elseif objecttargeting == "position" then
					if Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
						Ability.CastPosition(dodgeobject, Pugna.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
						Pugna.dodgeTiming = os.clock()
						Pugna.autododgerTable = {}
						return
					end
				elseif objecttargeting == "target" then
					Ability.CastTarget(dodgeobject, myHero)
					Pugna.dodgeTiming = os.clock()
					Pugna.autododgerTable = {}
					return
				end
			end
		end
	end

end

function Pugna.dodgeProcessing(myHero, unit, activity, castpoint)

	if not myHero then return end
	if Entity.IsSameTeam(myHero, unit) then return end

	local distance = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(unit)):Length2D() - 25

	if NPC.GetUnitName(unit) == "npc_dota_hero_antimage" then
		local radius = 500
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "antimage_mana_void", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end



	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_alchemist" then
		local radius = 0
		local castrange = 775
		local impactTime = distance / 900
		if activity == Enum.GameActivity.ACT_DOTA_ALCHEMIST_CONCOCTION_THROW then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint + impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "alchemist_unstable_concoction_throw", global = 0, type = "disable", projectilespeed = 900, projectileextradelay = -0.001})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end		
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_bane" then
		local radius = 0
		local castrange = 800
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "bane_fiends_grip", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end		
	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_batrider" then
		local radius = 0
		local castrange = 200
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "batrider_flaming_lasso", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end	

--	if NPC.GetUnitName(unit) == "npc_dota_hero_beastmaster" then
--		local radius = 
--		local castrange = 
--		if sequenceName == "cast4_primal_roar_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_bloodseeker" then
		local radius = 0
		local castrange = 1000
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "bloodseeker_rupture", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_centaur" then
		local radius = 315
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "centaur_hoof_stomp", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, 0)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_chaos_knight" then
		local radius = 0
		local castrange = 500
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "chaos_knight_chaos_bolt", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end	
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_crystal_maiden" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "crystal_maiden_frostbite", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_death_prophet" then
		local radius = 425
		local castrange = 1000
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, 425, 1000) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "death_prophet_silence", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_doom_bringer" then
		local radius = 0
		local castrange = 550
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_6 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "doom_bringer_doom", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_drow_ranger" then
		local radius = 900
		local castrange = 250
		local impactTime = distance / 2000 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "drow_ranger_wave_of_silence", global = 0, type = "disable", projectilespeed = 2000, projectileextradelay = 0.080})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_earthshaker" then
		local radius1 = 225
		local castrange = 1400
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius1, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "earthshaker_fissure", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius1, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end

		local radius2 = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius2) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "earthshaker_enchant_totem", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius2, 0)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_enigma" then
		local radius = 420
		local castrange = 275
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "enigma_black_hole", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_faceless_void" then
		local radius = 425
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "faceless_void_chronosphere", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_juggernaut" then
		local radius = 425
		local castrange = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "juggernaut_omni_slash", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_legion_commander" then
		local radius = 0
		local castrange = 300
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "legion_commander_duel", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lich" then
		local radius = 0
		local castrange = 1000
		local impactTime = distance / 850
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint + impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lich_chain_frost", global = 0, type = "nuke", projectilespeed = 850, projectileextradelay = 0})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lina" then
		local radius = 0
		local castrange = 725
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint + 0.275; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lina_laguna_blade", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lion" then
		local radius1 = 125
		local castrange1 = 725
		local impactTime = distance / 1600 - 0.2
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange1) and Pugna.dodgeIsTargetMe(myHero, unit, radius1, castrange1) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "lion_impale", global = 0, type = "disable", projectilespeed = 1600, projectileextradelay = 0.2})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange1+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius1, castrange1)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end

		local radius2 = 0
		local castrange2 = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius2+castrange2) and Pugna.dodgeIsTargetMe(myHero, unit, radius2, castrange2) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint + 0.275; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lion_finger_of_death", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+castrange2+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius2, castrange2)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_luna" then
		local radius = 0
		local castrange = 800
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "luna_lucent_beam", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_magnataur" then
		local radius = 0
		local castrange = 460
		local instant_radius = 150 + 50
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				local delay = castpoint
					if distance <= instant_radius then delay = 0 end
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "magnataur_reverse_polarity", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end	
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_necrolyte" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "necrolyte_reapers_scythe", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_night_stalker" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+0.075; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "night_stalker_crippling_fear", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_nyx_assassin" then
		local radius = 125
		local castrange = 700
		local impactTime = distance / 1600 + 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "nyx_assassin_impale", global = 0, type = "disable", projectilespeed = 1600, projectileextradelay = -0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_ogre_magi" then
		local radius = 0
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "ogre_magi_fireblast", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_obsidian_destroyer" then
		local radius1 = 0
		local castrange1 = 450
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange1) and Pugna.dodgeIsTargetMe(myHero, unit, radius1, castrange1) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "obsidian_destroyer_astral_imprisonment", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange1+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius1, castrange1)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end

		local radius2 = 575
		local castrange2 = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius2+castrange2) and Pugna.dodgeIsTargetMe(myHero, unit, radius2, castrange2) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "obsidian_destroyer_sanity_eclipse", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+castrange2+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius2, castrange2)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_puck" then
		local radius = 450
		local castrange = 0
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "puck_waning_rift", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_pudge" then
		local radius = 0
		local castrange = 250
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "pudge_dismember", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_queenofpain" then
		local radius = 450
		local castrange = 900
		local impactTime = distance / 900 - 0.25
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "queenofpain_sonic_wave", global = 0, type = "nuke", projectilespeed = 900, projectileextradelay = 0.25})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_rubick" then
		local radius = 0
		local castrange = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "rubick_telekinesis", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_shadow_demon" then
		local radius = 0
		local castrange = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "shadow_demon_disruption", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_shadow_shaman" then
		local radius = 0
		local castrange = 500
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_3 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "shadow_shaman_shackles", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_silencer" then
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "silencer_global_silence", global = 1, type = "disable"})
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_skywrath_mage" then
		local radius = 0
		local castrange = 750
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_3 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "skywrath_mage_ancient_seal", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_slardar" then
		local radius = 350
		local castrange = 0
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "slardar_slithereen_crush", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sniper" then
		local radius = 0
		local castrange = 3000
		local impactTime = distance / 2500 - 0.05
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then	
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "sniper_assassinate", global = 0, type = "nuke", projectilespeed = 2500, projectileextradelay = 0.05})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end
		

--	if NPC.GetUnitName(unit) == "npc_dota_hero_spirit_breaker" then
--		local radius = 0
--		local castrange = 850
--	--	if sequenceName == "ultimate_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "spirit_breaker_nether_strike", global = 0, type = "nuke"})
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_storm_spirit" then
		local radius = 0
		local castrange = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "storm_spirit_electric_vortex", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sven" then
		local radius = 0
		local castrange = 600
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "sven_storm_bolt", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_techies" then
--		local radius = 
--		local castrange = 
--		if sequenceName == "cast_blast_off" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_terrorblade" then
		local radius = 0
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "terrorblade_sunder", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_tidehunter" then
		local radius = 0
		local castrange = 1100
		local impactTime = distance / 775 - 0.35
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				local adjust = impactTime
					if distance <= 250 then adjust = 0 end
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint + adjust; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "tidehunter_ravage", global = 0, type = "disable", projectilespeed = 775, projectileextradelay = 0.35})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_tinker" then
		local radius = 0
		local castrange = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+0.1; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "tinker_laser", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_treant" then
--		local radius = 0
--		local castrange = 850
--		if sequenceName == "cast5_Overgrowth_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_vengefulspirit" then
		local radius = 0
		local castrange = 500
		local impactTime = distance / 1250 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "vengefulspirit_magic_missile", global = 0, type = "disable", projectilespeed = 1250, projectileextradelay = 0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_warlock" then
		local radius = 600
		local castrange = 1200
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+0.5; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "warlock_rain_of_chaos", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_windrunner" then
		local radius = 0
		local castrange = 800
		local impactTime = distance / 1650 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "windrunner_shackleshot", global = 0, type = "disable", projectilespeed = 1650, projectileextradelay = 0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_winter_wyvern" then
--		local radius = 500
--		local castrange = 800
--		if sequenceName == "cast04_winters_curse_flying_low_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_skeleton_king" then
		local radius = 0
		local castrange = 525
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "skeleton_king_hellfire_blast", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = Pugna.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						Pugna.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_zuus" then
		local radius = 375
		local castrange = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
			if Pugna.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "zuus_lightning_bolt", global = 0, type = "nuke"})
			end
		end

		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_5 then
			if Pugna.IsHeroInvisible(myHero) == false and not NPC.HasModifier(myHero, "modifier_smoke_of_deceit") then
				Pugna.autododger({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "zuus_thundergods_wrath", global = 1, type = "nuke"})
			end
		end
	end

end

-- ward awareness
function Pugna.wardProcessing(myHero)

	if not myHero then return end

	if os.clock() - Pugna.wardCaptureTiming < 0.5 then return end

	for i = 1, Heroes.Count() do
		local heroes = Heroes.Get(i)
		if heroes and Entity.IsHero(heroes) and Entity.IsAlive(heroes) and not Entity.IsDormant(heroes) and not Entity.IsSameTeam(myHero, heroes) and not NPC.IsIllusion(heroes) then
			local sentry = NPC.GetItem(heroes, "item_ward_sentry", true)
			local observer = NPC.GetItem(heroes, "item_ward_observer", true)
			local dispenser = NPC.GetItem(heroes, "item_ward_dispenser", true)
			local sentryStack = 0
			local observerStack = 0
			local ownerID = Entity.GetIndex(heroes)
			if sentry then
				sentryStack = Item.GetCurrentCharges(sentry)
			elseif observer then
				observerStack = Item.GetCurrentCharges(observer)
			elseif dispenser then
				sentryStack = Item.GetSecondaryCharges(dispenser)
				observerStack = Item.GetCurrentCharges(dispenser)
			end

			if sentryStack == 0 and observerStack == 0 then
				if Pugna.wardDispenserCount[ownerID] == nil then
					Pugna.wardDispenserCount[ownerID] = nil
					Pugna.wardCaptureTiming = os.clock()
				else
					if Pugna.wardDispenserCount[ownerID]["sentry"] > sentryStack then
						Pugna.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "sentry", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
						Pugna.wardDispenserCount[ownerID] = nil
						Pugna.wardCaptureTiming = os.clock()
					elseif Pugna.wardDispenserCount[ownerID]["observer"] > sentryStack then
						Pugna.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "observer", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
						Pugna.wardDispenserCount[ownerID] = nil
						Pugna.wardCaptureTiming = os.clock()
					end
				end
			end
						
			if Pugna.wardDispenserCount[ownerID] == nil then
				if sentryStack > 0 or observerStack > 0 then
					Pugna.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					Pugna.wardCaptureTiming = os.clock()
				end
			else
				if Pugna.wardDispenserCount[ownerID]["sentry"] < sentryStack then
					Pugna.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					Pugna.wardCaptureTiming = os.clock()
				elseif Pugna.wardDispenserCount[ownerID]["observer"] < observerStack then
					Pugna.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					Pugna.wardCaptureTiming = os.clock()
				elseif Pugna.wardDispenserCount[ownerID]["sentry"] > sentryStack then
					Pugna.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "sentry", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 240)}
					Pugna.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					Pugna.wardCaptureTiming = os.clock()
				elseif Pugna.wardDispenserCount[ownerID]["observer"] > observerStack then
					Pugna.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "observer", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
					Pugna.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					Pugna.wardCaptureTiming = os.clock()
				end
			end
		elseif heroes and Entity.IsHero(heroes) and Entity.IsDormant(heroes) then
			local ownerID = Entity.GetIndex(heroes)
			Pugna.wardDispenserCount[ownerID] = nil
			Pugna.wardCaptureTiming = os.clock()
		end
	end

	for k, l in pairs(Pugna.wardProcessingTable) do
		if l then
			if GameRules.GetGameTime() > l.dieTime then
				Pugna.wardProcessingTable[k] = nil
			end	
		end
	end

end

function Pugna.drawWard(myHero)

	if not myHero then return end

	if next(Pugna.wardProcessingTable) == nil then return end

	local sentryImageHandle = Pugna.sentryImageHandle
		if sentryImageHandle == nil then
			sentryImageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. "ward_sentry" .. ".png")
			Pugna.sentryImageHandle = sentryImageHandle
		end
	local obsImageHandle = Pugna.obsImageHandle
		if obsImageHandle == nil then
			obsImageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. "ward_observer" .. ".png")
			Pugna.obsImageHandle = obsImageHandle
		end

	for i, v in pairs(Pugna.wardProcessingTable) do
		if v then
			local type = v.type
			local pos = v.pos
			local dieTime = v.dieTime
			if dieTime > GameRules.GetGameTime() then
				local x, y = Renderer.WorldToScreen(pos)
				local visible = false
				local hoveringOver = Input.IsCursorInRect(x, y, 30, 30)
				
				if x > 0 and y > 0 then visible = true end
				if visible then
					if type == "sentry" then
						Renderer.SetDrawColor(255, 255, 255, 255)
						Renderer.DrawImage(sentryImageHandle, x, y, 30, 30)
						Renderer.DrawText(Pugna.font, x, y+30, math.floor(dieTime - GameRules.GetGameTime()), 0)
					elseif type == "observer" then
						Renderer.SetDrawColor(255, 255, 255, 255)
						Renderer.DrawImage(obsImageHandle, x, y, 30, 30)
						Renderer.DrawText(Pugna.font, x, y+30, math.floor(dieTime - GameRules.GetGameTime()), 0)
					end
					if Menu.IsEnabled(Pugna.optionWardAwarenessClickRemove) and (os.clock() - Pugna.wardDrawingRemove) >= 0.5 then
						if hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
							Pugna.wardDrawingRemove = os.clock()
						end
					else
						if hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
							Pugna.wardProcessingTable[i] = nil
							Pugna.wardDrawingRemove = 0
						end
					end
				end
			end
		end
	end

end

-- Items Cast functions
function Pugna.itemUsage(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(Pugna.optionItemEnable) then return end
	if (os.clock() - Pugna.lastItemTick) < Pugna.itemDelay then return end
	if Pugna.ItemCastStop then return end

	if Pugna.heroCanCastItems(myHero) == false then return end
	if Pugna.isHeroChannelling(myHero) == true then return end
	if Pugna.IsHeroInvisible(myHero) == true then return end

	if Menu.GetValue(Pugna.optionItemStyle) == 0 then 
		Pugna.itemUsageNoOrder(myHero, enemy)
	elseif Menu.GetValue(Pugna.optionItemStyle) == 1 then
		Pugna.itemUsageOrder(myHero, enemy)
	elseif Menu.GetValue(Pugna.optionItemStyle) == 2 then
		Pugna.itemUsageSmartOrder(myHero, enemy)
	end

end

function Pugna.itemUsageNoOrder(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local hex = NPC.GetItem(myHero, "item_sheepstick", true)
	local blood = NPC.GetItem(myHero, "item_bloodthorn", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local orchid = NPC.GetItem(myHero, "item_orchid", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)
	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)
	local abyssal = NPC.GetItem(myHero, "item_abyssal_blade", true)
	local halberd = NPC.GetItem(myHero, "item_heavens_halberd", true)
	local shivas = NPC.GetItem(myHero, "item_shivas_guard", true)
	local urn = NPC.GetItem(myHero, "item_urn_of_shadows", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local medallion = NPC.GetItem(myHero, "item_medallion_of_courage", true)
	local crest = NPC.GetItem(myHero, "item_solar_crest", true)
	local spiritVessel = NPC.GetItem(myHero, "item_spirit_vessel", true)
	local nullifier = NPC.GetItem(myHero, "item_nullifier", true)
	local diffusal = NPC.GetItem(myHero, "item_diffusal_blade", true)

	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if Menu.IsKeyDown(Pugna.optionComboKey) then
		
		if Pugna.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(Pugna.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			Pugna.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if Pugna.ItemSleepReady(0.05) and Pugna.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, Pugna.LinkensBreakerNew(myHero), true), enemy)
				Pugna.lastItemCast = os.clock()
				return
			end
		end

		if Pugna.ItemSleepReady(0.05) and abyssal and NPC.IsEntityInRange(myHero, enemy, 140) and Ability.IsCastable(abyssal, myMana) and Menu.GetValue(Pugna.optionItemAbyssal) > 0 then 
			Ability.CastTarget(abyssal, enemy)
			Pugna.lastItemCast = os.clock()
			return
		end

		if Pugna.ItemSleepReady(0.05) and shivas and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(shivas, myMana) and Menu.GetValue(Pugna.optionItemShivas) > 0 then 
			Ability.CastNoTarget(shivas)
			Pugna.lastItemCast = os.clock()
			return
		end

		if Pugna.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(Pugna.optionItemMjollnir) > 0 then 
			Ability.CastTarget(mjollnir, myHero)
			Pugna.lastItemCast = os.clock()
			return
		end

		if Pugna.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(Pugna.optionItemManta) > 0 then 
			Ability.CastNoTarget(manta)
			Pugna.lastItemCast = os.clock()
			return
		end

		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then

			if Pugna.ItemSleepReady(0.05) and orchid and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(orchid, myMana) and Menu.GetValue(Pugna.optionItemOrchid) > 0 then 
				Ability.CastTarget(orchid, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and blood and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(blood, myMana) and Menu.GetValue(Pugna.optionItemBlood) > 0 then 
				Ability.CastTarget(blood, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and veil and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(veil, myMana) and Menu.GetValue(Pugna.optionItemVeil) > 0 then 
				Ability.CastPosition(veil, Entity.GetAbsOrigin(enemy))
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and hex and NPC.IsEntityInRange(myHero, enemy, 800 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(hex, myMana) and Menu.GetValue(Pugna.optionItemHex) > 0 then 
				Ability.CastTarget(hex, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and nullifier and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(nullifier, myMana) and Menu.GetValue(Pugna.optionItemNull) > 0 then 
				Ability.CastTarget(nullifier, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and diffusal and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(diffusal, myMana) and Menu.GetValue(Pugna.optionItemDiffusal) > 0 then 
				Ability.CastTarget(diffusal, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and eBlade and NPC.IsEntityInRange(myHero, enemy, 800 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(eBlade, myMana) and Menu.GetValue(Pugna.optionItemeBlade) > 0 then 
				Ability.CastTarget(eBlade, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end
	
			if Pugna.ItemSleepReady(0.05) and atos and NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(atos, myMana) and Menu.GetValue(Pugna.optionItemAtos) > 0 then 
				Ability.CastTarget(atos, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and halberd and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(halberd, myMana) and Menu.GetValue(Pugna.optionItemHalberd) > 0 then
				Ability.CastTarget(halberd, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and urn and NPC.IsEntityInRange(myHero, enemy, 950 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(urn, myMana) and Item.GetCurrentCharges(urn) >= 3 and Entity.GetHealth(enemy) >= 250 and Menu.GetValue(Pugna.optionItemUrn) > 0 then
				Ability.CastTarget(urn, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and spiritVessel and NPC.IsEntityInRange(myHero, enemy, 950 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(spiritVessel, myMana) and Item.GetCurrentCharges(spiritVessel) >= 2 and Entity.GetHealth(enemy) >= 250 and Menu.GetValue(Pugna.optionItemSpirit) > 0 then
				Ability.CastTarget(spiritVessel, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and medallion and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(medallion, myMana) and Menu.GetValue(Pugna.optionItemMedallion) > 0 then 
				Ability.CastTarget(medallion, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and crest and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(crest, myMana) and Menu.GetValue(Pugna.optionItemCrest) > 0 then 
				Ability.CastTarget(crest, enemy)
				Pugna.lastItemCast = os.clock()
				return
			end

			if Pugna.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) and Menu.GetValue(Pugna.optionItemDagon) > 0 and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if eBlade then
					if Ability.SecondsSinceLastUse(eBlade) > -1 and Ability.SecondsSinceLastUse(eBlade) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
						return
					else
						Ability.CastTarget(dagon, enemy)
						Pugna.lastItemCast = os.clock()
						return
					end
				else
					if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
						if Ability.IsReady(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								Pugna.lastItemCast = os.clock()
								return
							end
						end
					elseif NPC.HasAbility(myHero, "witch_doctor_maledict") then
						if Ability.IsReady(NPC.GetAbility(myHero, "witch_doctor_maledict")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								Pugna.lastItemCast = os.clock()
								return
							end
						end
					elseif NPC.HasAbility(myHero, "pugna_decrepify") then
						if Ability.IsReady(NPC.GetAbility(myHero, "pugna_decrepify")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								Pugna.lastItemCast = os.clock()
								return
							end
						end
					else
						Ability.CastTarget(dagon, enemy)
						Pugna.lastItemCast = os.clock()
						return
					end
				end
			end

			if Menu.GetValue(Pugna.optionItemDagon) == -1 then

				if Pugna.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
					local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
					local eBladeAMP = 0
						if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
							eBladeAMP = 0.4
						end
					local necroUltDMG = 0
						if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
							if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
								local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
								necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
							end
						end
					local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
					if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
						if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
							Ability.CastTarget(dagon, enemy)
							Pugna.lastItemCast = os.clock()
							return
						end
					end
				end
			end
		end
	end
end

function Pugna.itemUsageOrder(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if Menu.IsKeyDown(Pugna.optionComboKey) then
		
		if Pugna.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(Pugna.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			Pugna.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if Pugna.ItemSleepReady(0.05) and Pugna.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, Pugna.LinkensBreakerNew(myHero), true), enemy)
				Pugna.lastItemCast = os.clock()
				return
			end
		end

		if Menu.GetValue(Pugna.optionItemDagon) == -1 then

			if Pugna.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
				local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
				local eBladeAMP = 0
					if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
						eBladeAMP = 0.4
					end
				local necroUltDMG = 0
					if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
						if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
							local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
							necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
						end
					end
				local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
				if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
					if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						Ability.CastTarget(dagon, enemy)
						Pugna.lastItemCast = os.clock()
						return
					end
				end
			end
		end

		local orderItem
		local customOrder = 0
		local itemActivation

		for k, v in ipairs(Pugna.ItemCastOrder) do

			local skipItem = 0

			if NPC.HasModifier(enemy, "modifier_black_king_bar_immune") then
				if v[2] == "item_veil_of_discord" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or
					v[2] == "item_ethereal_blade" or v[2] == "item_orchid" or v[2] == "item_rod_of_atos" or
					v[2] == "item_heavens_halberd" or v[2] == "item_urn_of_shadows" or v[2] == "item_dagon"
					or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" or v[2] == "item_medallion_of_courage" or v[2] == "item_solar_crest"
					or v[2] == "item_spirit_vessel" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if v[2] ~= "item_nullifier" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_ethereal_blade") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
				if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" then
					skipItem = v[1]
				end
			end

			if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "witch_doctor_maledict") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "pugna_decrepify") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if v[2] == "item_spirit_vessel" or v[2] == "item_urn_of_shadows" then
					if Item.GetCurrentCharges(NPC.GetItem(myHero, v[2], true)) <= 2 then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and (v[1] - skipItem) > customOrder then
					orderItem = NPC.GetItem(myHero, v[2], true)
					customOrder = v[1]
					itemActivation = v[3]
				end
			end	
		end
		
			if Pugna.ItemSleepReady(0.05) and customOrder > 0 then
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(orderItem)) then
					if itemActivation == "target" then
						Ability.CastTarget(orderItem, enemy)
						Pugna.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "no target" then
						Ability.CastNoTarget(orderItem)
						Pugna.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "position" then
						Ability.CastPosition(orderItem, Entity.GetAbsOrigin(enemy))
						Pugna.lastItemCast = os.clock()
						customOrder = 0
						return
					end
				end
			end

		if Pugna.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(Pugna.optionItemMjollnir) > 0 then
			Ability.CastTarget(mjollnir, myHero)
			Pugna.lastItemCast = os.clock()
			return
		end

		if Pugna.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(Pugna.optionItemManta) > 0 then
			Ability.CastNoTarget(manta)
			Pugna.lastItemCast = os.clock()
			return
		end
	end
end

function Pugna.itemUsageSmartOrder(myHero, enemy, activation)

	if not myHero then return end
	if not enemy then return end

	if Pugna.heroCanCastItems(myHero) == false then return end
	if Pugna.isHeroChannelling(myHero) == true then return end
	if Pugna.IsHeroInvisible(myHero) == true then return end

	local alternateActivation
	if activation == nil then
		alternateActivation = false
	else alternateActivation = activation
	end
	
	local myMana = NPC.GetMana(myHero)

	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if (Menu.IsKeyDown(Pugna.optionComboKey) or alternateActivation) then
		
		if Pugna.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(Pugna.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			Pugna.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if Pugna.ItemSleepReady(0.05) and Pugna.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, Pugna.LinkensBreakerNew(myHero), true), enemy)
				Pugna.lastItemCast = os.clock()
				return
			end
		end

		if Menu.GetValue(Pugna.optionItemDagon) == -1 then

			if Pugna.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
				local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
				local eBladeAMP = 0
					if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
						eBladeAMP = 0.4
					end
				local necroUltDMG = 0
					if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
						if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
							local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
							necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
						end
					end
				local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
				if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
					if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						Ability.CastTarget(dagon, enemy)
						Pugna.lastItemCast = os.clock()
						return
					end
				end
			end
		end

		local orderItem
		local customOrder = 0
		local itemActivation

		for k, v in ipairs(Pugna.ItemCastOrder) do

			local skipItem = 0

			if NPC.HasModifier(enemy, "modifier_black_king_bar_immune") then
				if v[2] == "item_veil_of_discord" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or
					v[2] == "item_ethereal_blade" or v[2] == "item_orchid" or v[2] == "item_rod_of_atos" or
					v[2] == "item_heavens_halberd" or v[2] == "item_urn_of_shadows" or v[2] == "item_dagon"
					or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" or v[2] == "item_medallion_of_courage" or v[2] == "item_solar_crest"
					or v[2] == "item_spirit_vessel" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if v[2] ~= "item_nullifier" then
					skipItem = v[1]
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if v[2] == "item_spirit_vessel" or v[2] == "item_urn_of_shadows" then
					if Item.GetCurrentCharges(NPC.GetItem(myHero, v[2], true)) <= 2 then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_bashed") then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_stunned") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_stunned"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_sheepstick_debuff"))
				if Menu.IsEnabled(Pugna.optionItemStack) then
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
							skipItem = v[1]
						end
					end
				else
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
							skipItem = v[1]
						end
					end
				end
			end

			if NPC.HasItem(myHero, "item_sheepstick", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) < 0.5 then
				if Menu.IsEnabled(Pugna.optionItemStack) then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				else
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.IsSilenced(enemy) then
				if NPC.HasModifier(enemy, "modifier_bloodthorn_debuff") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_bloodthorn_debuff"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				elseif NPC.HasModifier(enemy, "modifier_orchid_malevolence_debuff") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_orchid_malevolence_debuff"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				elseif NPC.HasModifier(enemy, "modifier_silence") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_silence"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_nullifier") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1200) + 0.25 then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_nullifier_mute") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_nullifier_mute"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if  v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_diffusal_blade_slow") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_diffusal_blade_slow"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, "item_diffusal_blade", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) < 0.5 then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_ethereal_blade") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
				if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_veil_of_discord_debuff") then
				if v[2] == "item_veil_of_discord" then
					skipItem = v[1]
				end
			end		

			if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "witch_doctor_maledict") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "pugna_decrepify") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(enemy, "item_aeon_disk", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) < 0 then
					if Entity.GetHealth(enemy) >= 0.85 * Entity.GetMaxHealth(enemy) then
						if v[2] == "item_nullifier" then
							skipItem = v[1]
						end
					end
				end
				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) <= 2.55 then
					if not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						if v[2] == "item_nullifier" then
							skipItem = v[1]
						end
					end
				end
			end

			if Pugna.myUnitName == "npc_dota_hero_tinker" then
				if NPC.IsLinkensProtected(enemy) then
					if v[2] == "item_sheepstick" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_pudge_meat_hook") then
				if v[2] == "item_rod_of_atos" then
					skipItem = v[1]
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and (v[1] - skipItem) > customOrder then
					orderItem = NPC.GetItem(myHero, v[2], true)
					customOrder = v[1]
					itemActivation = v[3]
				end
			end	
		end
		
			if Pugna.ItemSleepReady(0.05) and customOrder > 0 then
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(orderItem)) then
					if itemActivation == "target" then
						Ability.CastTarget(orderItem, enemy)
						Pugna.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "no target" then
						Ability.CastNoTarget(orderItem)
						Pugna.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "position" then
						Ability.CastPosition(orderItem, Entity.GetAbsOrigin(enemy))
						Pugna.lastItemCast = os.clock()
						customOrder = 0
						return
					end
				end
			end

		if Pugna.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(Pugna.optionItemMjollnir) > 0 then
			Ability.CastTarget(mjollnir, myHero)
			Pugna.lastItemCast = os.clock()
			return
		end

		if Pugna.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(Pugna.optionItemManta) > 0 then
			Ability.CastNoTarget(manta)
			Pugna.lastItemCast = os.clock()
			return
		end
	end
end

function Pugna.ItemAutoHurricaneUsage(myHero, enemy)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local orbSkill = nil
	local orbSkillTable = {
		npc_dota_hero_clinkz = "clinkz_searing_arrows",
		npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
		npc_dota_hero_enchantress = "enchantress_impetus",
		npc_dota_hero_huskar = "huskar_burning_spear",
		npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
		npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
		npc_dota_hero_viper = "viper_poison_attack",
		npc_dota_hero_skywrath_mage = "skywrath_mage_arcane_bolt"
			}

		if orbSkillTable[Pugna.myUnitName] ~= nil then
			orbSkill = NPC.GetAbility(myHero, orbSkillTable[Pugna.myUnitName])
		end

		if orbSkill and Ability.GetLevel(orbSkill) < 1 then
			orbSkill = nil
		end

		if orbSkill then
			if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then
				if Ability.GetAutoCastState(orbSkill) == false and os.clock() - Pugna.lastTick > 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO, nil, Vector(), orbSkill, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
					Pugna.lastTick = os.clock()
					return
				end
			end
		end


	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)
		if not hurricanePike then return end
		if not Ability.IsCastable(hurricanePike, myMana) then return end

	if Pugna.heroCanCastItems(myHero) == false then return end
	if Pugna.isHeroChannelling(myHero) == true then return end
	if Pugna.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_item_blade_mail_reflect") then return end
	if NPC.HasItem(myHero, "item_blade_mail", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) < 0.25 then return end

	if os.clock() - Pugna.lastDefItemPop < 0.25 then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(Pugna.optionItemHurricaneHP) then
		for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 400, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.IsAttacking(v) then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.FindFacingNPC(v) == myHero then
							if enemy then
								if NPC.IsEntityInRange(myHero, enemy, 400) then
									Ability.CastTarget(hurricanePike, enemy)
									Pugna.lastDefItemPop = os.clock()
									break
									return
								else
									if NPC.IsEntityInRange(myHero, v, 400) then
										Ability.CastTarget(hurricanePike, v)
										Pugna.lastDefItemPop = os.clock()
										break
										return
									end
								end
							else
								if NPC.IsEntityInRange(myHero, v, 400) then
									Ability.CastTarget(hurricanePike, v)
									Pugna.lastDefItemPop = os.clock()
									break
									return
								end
							end	
						end
					end
				end
				for ability, info in pairs(Pugna.RawDamageAbilityEstimation) do
					if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
						local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
						local abilityRadius = info[3]
						if Pugna.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							if next(Pugna.autododgerTable) == nil then
								if enemy then
									if NPC.IsEntityInRange(myHero, enemy, 400) then
										Ability.CastTarget(hurricanePike, enemy)
										Pugna.lastDefItemPop = os.clock()
										break
										return
									end
								else
									if NPC.IsEntityInRange(myHero, v, 400) then
										Ability.CastTarget(hurricanePike, v)
										Pugna.lastDefItemPop = os.clock()
										break
										return
									end
								end
							end
						end
					end
				end
			end	
		end
	end

end

function Pugna.ItemAutoBMUsage(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local bladeMail = NPC.GetItem(myHero, "item_blade_mail", true)
		if not bladeMail then return end
		if not Ability.IsCastable(bladeMail, myMana) then return end

	if Pugna.heroCanCastItems(myHero) == false then return end
	if Pugna.isHeroChannelling(myHero) == true then return end
	if Pugna.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then return end
	if NPC.HasItem(myHero, "item_hurricane_pike", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) < 0.25 then return end

	if os.clock() - Pugna.lastDefItemPop < 0.25 then return end

	for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			if NPC.IsAttacking(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
					if NPC.FindFacingNPC(v) == myHero then
						Ability.CastNoTarget(bladeMail)
						Pugna.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
			for ability, info in pairs(Pugna.RawDamageAbilityEstimation) do
				if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
					local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
					local abilityRadius = info[3]
					if Pugna.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
						if next(Pugna.autododgerTable) == nil then
							Ability.CastNoTarget(bladeMail)
							Pugna.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end	
	end
	return
	
end


-- linken
function Pugna.LinkensBreakerNew(myHero)

	if not myHero then return end

	if not Menu.IsEnabled(Pugna.optionLinkensEnable) then return end

	local myMana = NPC.GetMana(myHero)

 	local prioItem
	local prioOrder = 0

	for k, v in ipairs(Pugna.LinkensBreakerItemOrder) do
	
		if NPC.HasItem(myHero, v[2], true) then
			if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and v[1] > prioOrder then
					prioItem = v[2]
					prioOrder = v[1]
				
			end
		end	
	
	end
	return prioItem	
end
	
-- UT ITEMS
function Pugna.utilityItemUsage(myHero)

	if not myHero then return end

	if Pugna.heroCanCastItems(myHero) == false then return end
	if Pugna.isHeroChannelling(myHero) == true then return end
	if Pugna.IsHeroInvisible(myHero) == true then return end

	local stick = NPC.GetItem(myHero, "item_magic_stick", true)
	local wand = NPC.GetItem(myHero, "item_magic_wand", true)
	local mekansm = NPC.GetItem(myHero, "item_mekansm", true)
	local greaves = NPC.GetItem(myHero, "item_guardian_greaves", true)
	local arcane = NPC.GetItem(myHero, "item_arcane_boots", true)
	local midas = NPC.GetItem(myHero, "item_hand_of_midas", true)
	local cheese = NPC.GetItem(myHero, "item_cheese", true)
	local faerie = NPC.GetItem(myHero, "item_faerie_fire", true)
	local bottle = NPC.GetItem(myHero, "item_bottle", true)

	local myMana = NPC.GetMana(myHero)

	if (stick or wand or cheese or faerie) and Menu.IsEnabled(Pugna.optionUtilityStick) then
		Pugna.utilityItemStick(myHero, stick, wand, cheese, faerie)
	end
	if mekansm and Menu.IsEnabled(Pugna.optionUtilityMek) then
		Pugna.utilityItemMek(myHero, mekansm, myMana)
	end
	if greaves and Menu.IsEnabled(Pugna.optionUtilityGreaves) then
		Pugna.utilityItemGreaves(myHero, greaves)
	end
	if arcane and Menu.IsEnabled(Pugna.optionUtilityArcane) then
		Pugna.utilityItemArcane(myHero, arcane)
	end
	if midas and Menu.IsEnabled(Pugna.optionUtilityMidas) then
		Pugna.utilityItemMidas(myHero, midas)
	end
	if bottle and Menu.IsEnabled(Pugna.optionUtilityBottle) then
		Pugna.utilityItemBottle(myHero, bottle)
	end

end

function Pugna.utilityItemStick(myHero, stick, wand, cheese, faerie)

	if not myHero then return end
	if (Entity.GetAbsOrigin(myHero) - Pugna.GetMyFountainPos(myHero)):Length2D() < 1500 then return end
	
	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	
	if Entity.IsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then
		if stick and myHealthPerc <= Menu.GetValue(Pugna.optionUtilityHealth) and Ability.IsReady(stick) then
			if Item.GetCurrentCharges(stick) >= 1 then 
				Ability.CastNoTarget(stick)
				return
			end
		end
		if wand and myHealthPerc <= Menu.GetValue(Pugna.optionUtilityHealth) and Ability.IsReady(wand) then 
			if Item.GetCurrentCharges(wand) >= 1 then 
				Ability.CastNoTarget(wand)
				return
			end
		end
		if cheese and myHealthPerc <= Menu.GetValue(Pugna.optionUtilityHealth) and Ability.IsReady(cheese) then 
			Ability.CastNoTarget(cheese)
			return
		end
		if faerie and myHealthPerc <= Menu.GetValue(Pugna.optionUtilityHealth) and Ability.IsReady(faerie) then 
			Ability.CastNoTarget(faerie)
			return
		end
	end
end

function Pugna.utilityItemBottle(myHero, bottle)

	if not myHero then return end
	if not bottle then return end
		if Item.GetCurrentCharges(bottle) < 2 then return end

	if Ability.SecondsSinceLastUse(bottle) > -1 and Ability.SecondsSinceLastUse(bottle) < 0.5 then return end
	if os.clock() < Pugna.lastTick then return end

	for i = 1, Abilities.Count() do 
		local abilities = Abilities.Get(i)

		if Entity.GetOwner(abilities) == myHero then
			if Ability.SecondsSinceLastUse(abilities) > -1 and Ability.SecondsSinceLastUse(abilities) < 0.5 then 
				return
			end
		end
	end

	if NPC.HasModifier(myHero, "modifier_bottle_regeneration") then return end
	if not NPC.HasModifier(myHero, "modifier_item_empty_bottle") then return end

	local hpGap = Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)
	local manaGap = NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)

	for i, v in ipairs(Entity.GetUnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsNPC(v) and Entity.IsAlive(v) and not Entity.IsDormant(v) then
			if Entity.IsHero(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 250) then
					return
				end
			else
				if NPC.GetUnitName(v) == "npc_dota_roshan" then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 375) then
						return
					end
				end
			end	
		end
	end
			
	if hpGap < 0.75 then
		Ability.CastNoTarget(bottle)
		return
	end

	if manaGap < 0.75 then
		Ability.CastNoTarget(bottle)
		return
	end

	return

end

function Pugna.utilityItemMek(myHero, mekansm, myMana)

	if not myHero then return end
	if not mekansm then return end

	if (Entity.GetAbsOrigin(myHero) - Pugna.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Ability.IsCastable(mekansm, myMana) then
		if Entity.IsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then	
			if (myHealthPerc <= Menu.GetValue(Pugna.optionUtilityHealth)) and Ability.IsCastable(mekansm, myMana) then 
				Ability.CastNoTarget(mekansm) 
				return
			end
		end

		for _, teamMates in ipairs(Entity.GetHeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Entity.IsAlive(myHero) and Entity.IsAlive(teamMates) and not NPC.HasModifier(teamMates, "modifier_ice_blast") then	
					if (Entity.GetHealth(teamMates) / Entity.GetMaxHealth(teamMates)) * 100 <= Menu.GetValue(Pugna.optionUtilityHealth) and Ability.IsCastable(mekansm, myMana) then
						for _, v in ipairs(Entity.GetHeroesInRadius(teamMates, 1000, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
								if NPC.FindFacingNPC(v) == teamMates then
									Ability.CastNoTarget(mekansm) 
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
end

function Pugna.utilityItemGreaves(myHero, greaves)

	if not myHero then return end
	if not greaves then return end

	if (Entity.GetAbsOrigin(myHero) - Pugna.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Ability.IsReady(greaves) then
		if Entity.IsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then	
			if greaves and (myHealthPerc <= Menu.GetValue(Pugna.optionUtilityHealth)) and Ability.IsReady(greaves) then 
				Ability.CastNoTarget(greaves) 
				return
			end
		end

		for _, teamMates in ipairs(Entity.GetHeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Entity.IsAlive(myHero) and Entity.IsAlive(teamMates) and not NPC.HasModifier(teamMates, "modifier_ice_blast") then	
					if greaves and (Entity.GetHealth(teamMates) / Entity.GetMaxHealth(teamMates)) * 100 <= Menu.GetValue(Pugna.optionUtilityHealth) and Ability.IsReady(greaves) then
						for _, v in ipairs(Entity.GetHeroesInRadius(teamMates, 1000, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
								if NPC.FindFacingNPC(v) == teamMates then
									Ability.CastNoTarget(greaves) 
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
end

function Pugna.utilityItemArcane(myHero, arcane)

	if not myHero then return end
	if not arcane then return end

	if (Entity.GetAbsOrigin(myHero) - Pugna.GetMyFountainPos(myHero)):Length2D() < 3000 then return end

	local myManaMissing = NPC.GetMaxMana(myHero) - NPC.GetMana(myHero)

	if Ability.IsReady(arcane) then
		if Entity.IsAlive(myHero) then
			if arcane and myManaMissing >= 200 then 
				Ability.CastNoTarget(arcane)
				return 
			end
		end


		for _, teamMates in ipairs(Entity.GetHeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Entity.IsAlive(myHero) and Entity.IsAlive(teamMates) then
					if arcane and (NPC.GetMana(teamMates) / NPC.GetMaxMana(teamMates)) * 100 <= 40 and Ability.IsReady(arcane) then 
						Ability.CastNoTarget(arcane)
						break
						return
					end
				end 
			end
		end
	end
end


function Pugna.useDefensiveItems(myHero, enemy)

	if not myHero then return end
	if not Menu.IsEnabled(Pugna.optionDefensiveItems) then return end

	if (Entity.GetAbsOrigin(myHero) - Pugna.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	if os.clock() - Pugna.lastDefItemPop < 0.25 then return end

	if Pugna.ItemCastStop then return end

	if Pugna.heroCanCastItems(myHero) == false then return end
	if Pugna.IsHeroInvisible(myHero) == true then return end

	local myMana = NPC.GetMana(myHero)

	local glimmerCape = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local lotusOrb = NPC.GetItem(myHero, "item_lotus_orb", true)
	local crimsonGuard = NPC.GetItem(myHero, "item_crimson_guard", true)
	local pipe = NPC.GetItem(myHero, "item_pipe", true)
	local solarCrest = NPC.GetItem(myHero, "item_solar_crest", true)
	local BKB = NPC.GetItem(myHero, "item_black_king_bar", true)
	local satanic = NPC.GetItem(myHero, "item_satanic", true)
	local medallion = NPC.GetItem(myHero, "item_medallion_of_courage", true)
	local ghost = NPC.GetItem(myHero, "item_ghost", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)


	local channellingTable = {
		"bane_fiends_grip",
		"crystal_maiden_freezing_field",
		"enigma_black_hole",
		"pudge_dismember",
		"pugna_life_drain",
		"sandking_epicenter",
		"shadow_shaman_shackles",
		"warlock_upheaval",
		"witch_doctor_death_ward"
				}

	if Menu.IsEnabled(Pugna.optionDefensiveItemsGlimmer) then
		if glimmerCape and Ability.IsCastable(glimmerCape, myMana) then
			if Pugna.IsNPCinDanger(myHero, myHero) then
				Ability.CastTarget(glimmerCape, myHero)
				Pugna.lastDefItemPop = os.clock()
				return
			end
			if NPC.IsChannellingAbility(myHero) then
				for _, ability in ipairs(channellingTable) do
					if NPC.HasAbility(myHero, ability) and Ability.IsChannelling(NPC.GetAbility(myHero, ability)) then
						Ability.CastTarget(glimmerCape, myHero)
						Pugna.lastDefItemPop = os.clock()
						return
					end
				end
			end
			if NPC.HasModifier(myHero, "modifier_teleporting") then
				local myFountain = Pugna.GetMyFountainPos(myHero)
				if not NPC.IsPositionInRange(myHero, myFountain, 2500, 0) then
					Ability.CastTarget(glimmerCape, myHero)
					Pugna.lastDefItemPop = os.clock()
					return
				end
			end
			if Menu.IsEnabled(Pugna.optionDefensiveItemsAlly) then
				local teamMatesAround = Entity.GetHeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if Pugna.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(glimmerCape, ally)
							Pugna.lastDefItemPop = os.clock()
							break
							return
						end
						if NPC.IsChannellingAbility(ally) then
							for _, ability in ipairs(channellingTable) do
								if NPC.HasAbility(ally, ability) and Ability.IsChannelling(NPC.GetAbility(ally, ability)) then
									Ability.CastTarget(glimmerCape, ally)
									Pugna.lastDefItemPop = os.clock()
									return
								end
							end
						end
					end
				end
			end
		end
	end

	if Pugna.isHeroChannelling(myHero) == true then return end

	if Menu.IsEnabled(Pugna.optionDefensiveItemsGhost) then
		if ghost and Ability.IsReady(ghost) then
			if Entity.GetHealth(myHero) <= Menu.GetValue(Pugna.optionDefensiveItemsThreshold)/100 * Entity.GetMaxHealth(myHero) then
				for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
					if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
						if NPC.FindFacingNPC(v) == myHero then
							if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
								if NPC.IsAttacking(v) then
									Ability.CastNoTarget(ghost)
									Pugna.lastDefItemPop = os.clock()
									break
									return
								end
							end
						end
					end
				end	
			end
		end
	end
				
	if Menu.IsEnabled(Pugna.optionDefensiveItemslotusOrb) then
		if lotusOrb and Ability.IsCastable(lotusOrb, myMana) then
			if Pugna.IsNPCinDanger(myHero, myHero) then
				Ability.CastTarget(lotusOrb, myHero)
				Pugna.lastDefItemPop = os.clock()
				return
			end
			if Menu.IsEnabled(Pugna.optionDefensiveItemsAlly) then
				local teamMatesAround = Entity.GetHeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if Pugna.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(lotusOrb, ally)
							Pugna.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end
	
	if Menu.IsEnabled(Pugna.optionDefensiveItemsCrimson) then
		if crimsonGuard and Ability.IsCastable(crimsonGuard, myMana) then
			if Pugna.IsNPCinDanger(myHero, myHero) then
				Ability.CastNoTarget(crimsonGuard)
				Pugna.lastDefItemPop = os.clock()
				return
			end
			local teamMatesAround = Entity.GetHeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
					if Pugna.IsNPCinDanger(myHero, ally) then
						Ability.CastNoTarget(crimsonGuard)
						Pugna.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
		end
	end

	if Menu.IsEnabled(Pugna.optionDefensiveItemsCrest) then
		if solarCrest and Ability.IsCastable(solarCrest, myMana) then
			if Menu.IsEnabled(Pugna.optionDefensiveItemsAlly) then
				local teamMatesAround = Entity.GetHeroesInRadius(myHero, 975, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if Pugna.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(solarCrest, ally)
							Pugna.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(Pugna.optionDefensiveItemsMedallion) then
		if medallion and Ability.IsCastable(medallion, myMana) then
			if Menu.IsEnabled(Pugna.optionDefensiveItemsAlly) then
				local teamMatesAround = Entity.GetHeroesInRadius(myHero, 975, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if Pugna.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(medallion, ally)
							Pugna.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(Pugna.optionDefensiveItemsPipe) then
		if pipe and Ability.IsCastable(pipe, myMana) then
			if Pugna.IsNPCinDanger(myHero, myHero) then
				Ability.CastNoTarget(pipe)
				Pugna.lastDefItemPop = os.clock()
				return
			end
			local teamMatesAround = Entity.GetHeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
					if Pugna.IsNPCinDanger(myHero, ally) then
						Ability.CastNoTarget(pipe)
						Pugna.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
		end
	end

	if Menu.IsEnabled(Pugna.optionDefensiveItemsBKB) then
		if BKB and Ability.IsReady(BKB) then
			if Pugna.shouldCastBKB(myHero) == true then
				Ability.CastNoTarget(BKB)
				Pugna.lastDefItemPop = os.clock()
				return
			end
		end
	end
	
	if Menu.IsEnabled(Pugna.optionDefensiveItemsSatanic) then
		if satanic and Ability.IsCastable(satanic, myMana) then			
			if Pugna.shouldCastSatanic(myHero, enemy) == true then
				Ability.CastNoTarget(satanic)
				Pugna.lastDefItemPop = os.clock()
				return
			end
		end
	end
end

function Pugna.IsNPCinDanger(myHero, npc)

	if not myHero then return false end
	if not npc or NPC.IsIllusion(npc) or not Entity.IsAlive(npc) then return false end

	if NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end
	if NPC.HasModifier(npc, "modifier_item_lotus_orb_active") then return false end

	if NPC.HasModifier(npc, "modifier_dazzle_shallow_grave") then return false end
	if Pugna.IsHeroInvisible(npc) == true then return false end
	if NPC.HasModifier(npc, "modifier_fountain_aura_buff") then return false end

	if #Entity.GetHeroesInRadius(npc, 1500, Enum.TeamType.TEAM_ENEMY) < 1 then return false end
	if #Entity.GetHeroesInRadius(myHero, 1500, Enum.TeamType.TEAM_ENEMY) < 1 then return false end
	if (Entity.GetAbsOrigin(myHero) - Pugna.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	if NPC.GetUnitName(npc) == "npc_dota_hero_monkey_king" then
		if NPC.GetAbilityByIndex(npc, 1) ~= nil then
			if Ability.SecondsSinceLastUse(NPC.GetAbilityByIndex(npc, 1)) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbilityByIndex(npc, 1)) < 2 then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_nyx_assassin" then
		if NPC.GetAbility(npc, "nyx_assassin_burrow") ~= nil and Ability.GetLevel(NPC.GetAbility(npc, "nyx_assassin_burrow")) > 0 then
			if Ability.IsInAbilityPhase(NPC.GetAbility(npc, "nyx_assassin_burrow")) then
				return false
			elseif not Ability.IsHidden(NPC.GetAbility(npc, "nyx_assassin_unburrow")) then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_sand_king" then
		if NPC.GetAbility(npc, "sandking_burrowstrike") ~= nil then
			local burrow = NPC.GetAbility(npc, "sandking_burrowstrike")
			if Ability.SecondsSinceLastUse(burrow) > -1 and Ability.SecondsSinceLastUse(burrow) < 1 then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_earth_spirit" then
		if NPC.GetAbility(npc, "earth_spirit_rolling_boulder") ~= nil then
			local boulder = NPC.GetAbility(npc, "earth_spirit_rolling_boulder")
			if Ability.SecondsSinceLastUse(boulder) > -1 and Ability.SecondsSinceLastUse(boulder) < 2 then
				return false
			end
		end
	end
	
	local momSilenced = false
	if NPC.HasItem(npc, "item_mask_of_madness", true) then
		local mom = NPC.GetItem(npc, "item_mask_of_madness", true)
		if Ability.SecondsSinceLastUse(mom) > -1 and Ability.SecondsSinceLastUse(mom) < 8 then
			momSilenced = true
		end
	end

	if NPC.HasModifier(npc, "modifier_nyx_assassin_burrow") then return false end
	if NPC.HasModifier(npc, "modifier_monkey_king_tree_dance_activity") then return false end

	if Pugna.TargetGotDisableModifier(myHero, npc) == true or (NPC.IsSilenced(npc) and not momSilenced) or
		NPC.HasModifier(npc, "modifier_item_nullifier_mute") or NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_HEXED) then

		if Entity.GetHealth(npc) / Entity.GetMaxHealth(npc) <= (Menu.GetValue(Pugna.optionDefensiveItemsThresholdDisable) / 100) then
			for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
				if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
					if NPC.FindFacingNPC(v) == npc or NPC.IsEntityInRange(npc, v, NPC.GetAttackRange(v) + 150) then
						return true
					end
				end
			end
		end
	end

	if Entity.GetHealth(npc) <= Menu.GetValue(Pugna.optionDefensiveItemsThreshold)/100 * Entity.GetMaxHealth(npc) then
		for _, v in ipairs(Entity.GetHeroesInRadius(npc, 1000, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
				if NPC.FindFacingNPC(v) == npc then
					return true
				end
			end
		end
	end

	return false

end

function Pugna.IsHeroInvisible(myHero)

	if not myHero then return false end
	if not Entity.IsAlive(myHero) then return false end

	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVISIBLE) then return true end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return true end
	if NPC.HasAbility(myHero, "invoker_ghost_walk") then
		if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 1 then 
			return true
		end
	end

	if NPC.HasItem(myHero, "item_invis_sword", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) < 1 then 
			return true
		end
	end
	if NPC.HasItem(myHero, "item_silver_edge", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) < 1 then 
			return true
		end
	end

	return false
		
end

function Pugna.TargetGotDisableModifier(myHero, npc)

	if not myHero then return false end
	if not npc then return false end

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_item_rod_of_atos_debuff",
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(npc, modifier) then
			searchMod = NPC.GetModifier(npc, modifier)
			break
		end
	end

	local timeleft = 0
	if searchMod then
		if NPC.HasModifier(npc, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				timeleft = Modifier.GetCreationTime(searchMod) + 4
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				timeleft = Modifier.GetCreationTime(searchMod) + 4.5
			else
				timeleft = Modifier.GetDieTime(searchMod)
			end
		else
			timeleft = 0
		end
	else
		timeleft = 0
	end

	if timeleft > 0.75 then
		return true
	end

	return false

end

function Pugna.heroCanCastSpells(myHero, enemy)

	if not myHero then return false end
	if not Entity.IsAlive(myHero) then return false end

	if NPC.IsSilenced(myHero) then return false end 
	if NPC.IsStunned(myHero) then return false end
	if NPC.HasModifier(myHero, "modifier_bashed") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	
	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end
	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	
	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end
	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end
	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end
	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end
	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end
	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end
	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end
	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end
	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end
	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end
	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end

	if enemy then
		if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then return false end
	end

	return true	

end

function Pugna.heroCanCastItems(myHero)

	if not myHero then return false end
	if not Entity.IsAlive(myHero) then return false end

	if NPC.IsStunned(myHero) then return false end
	if NPC.HasModifier(myHero, "modifier_bashed") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	
	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end
	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	
	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end
	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end
	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end
	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end
	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end
	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end
	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end
	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end
	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end
	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end
	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end

	return true	

end

function Pugna.isHeroChannelling(myHero)

	if not myHero then return true end

	if NPC.IsChannellingAbility(myHero) then return true end
	if NPC.HasModifier(myHero, "modifier_teleporting") then return true end

	return false

end

function Pugna.shouldCastBKB(myHero)

	if not myHero then return end

	local dangerousRangeTable = {
		alchemist_unstable_concoction_throw = 775,
		beastmaster_primal_roar = 600,
		centaur_hoof_stomp = 315,
		chaos_knight_chaos_bolt = 500,
		crystal_maiden_frostbite = 525,
		dragon_knight_dragon_tail = 400,
		drow_ranger_wave_of_silence = 900,
		earth_spirit_boulder_smash = 300,
		earthshaker_fissure = 1400,
		ember_spirit_searing_chains = 400,
		invoker_tornado = 1000,
		jakiro_ice_path = 1200,
		lion_impale = 500,
		lion_voodoo = 500,
		naga_siren_ensnare = 650,
		nyx_assassin_impale = 700,
		puck_dream_coil = 750,
		rubick_telekinesis = 625,
		sandking_burrowstrike = 650,
		shadow_shaman_shackles = 400,
		shadow_shaman_voodoo = 500,
		skeleton_king_hellfire_blast = 525,
		slardar_slithereen_crush = 400,
		storm_spirit_electric_vortex = 400,
		sven_storm_bolt = 600,
		tidehunter_ravage = 1025,
		tiny_avalanche = 600,
		vengefulspirit_magic_missile = 500,
		warlock_rain_of_chaos = 1200,
		windrunner_shackleshot = 800,
		slark_pounce = 700,
		ogre_magi_fireblast = 475,
		meepo_poof = 400
			}

	local enemyTable = {}
	local enemiesAround = Entity.GetHeroesInRadius(myHero, Menu.GetValue(Pugna.optionDefensiveItemsBKBRadius), Enum.TeamType.TEAM_ENEMY)
		for _, enemy in ipairs(enemiesAround) do
			if enemy then
				if not Entity.IsDormant(enemy) and not NPC.IsIllusion(enemy) and not NPC.IsStunned(enemy) and not NPC.IsSilenced(enemy) then
					table.insert(enemyTable, enemy)
				end
			end
		end

	if next(enemyTable) == nil then return false end

	local tempTable = {}
	for i = 1, #Pugna.preemptiveBKBtable do
		if Menu.IsEnabled(Pugna.preemptiveBKB[i]) then
			table.insert(tempTable, Pugna.preemptiveBKBtable[i])
		end
	end

	if next(tempTable) == nil then return false end

	local searchAbility
	for _, enemy in ipairs(enemyTable) do
		for _, ability in ipairs(tempTable) do
			if NPC.HasAbility(enemy, ability) then
				if NPC.GetAbility(enemy, ability) ~= nil and Ability.IsReady(NPC.GetAbility(enemy, ability)) then
					if Ability.GetLevel(NPC.GetAbility(enemy, ability)) > 0 and Ability.GetCooldownTimeLeft(NPC.GetAbility(enemy, ability)) < 1 and not Ability.IsHidden(NPC.GetAbility(enemy, ability)) then
						if dangerousRangeTable[ability] > (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() then
							searchAbility = ability
							break
						end
					end
				end
			end
		end
	end

	if searchAbility ~= nil and #enemyTable >= Menu.GetValue(Pugna.optionDefensiveItemsBKBEnemies) then
		return true
	end

	return false

end

function Pugna.shouldCastSatanic(myHero, enemy)

	if not myHero then return end
	if not enemy then return false end
	if Entity.GetHealth(myHero) > Entity.GetMaxHealth(myHero) * 0.3 then return false end

	if enemy then
		if NPC.IsAttacking(myHero) and Entity.GetHealth(enemy) >= Entity.GetMaxHealth(enemy) * 0.25 then
			return true
		end
	end

	return false

end

--Hero Combo

function Pugna.PugnaCombo(myHero, enemy)

	if not Menu.IsEnabled(Pugna.optionEnable) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local E = NPC.GetAbilityByIndex(myHero, 2)
	local ult = NPC.GetAbility(myHero, "pugna_life_drain")
		if ult and Ability.SecondsSinceLastUse(ult) > -1 and Ability.SecondsSinceLastUse(ult) < 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)) then
			return
		end

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	Pugna.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(Pugna.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and Pugna.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 700) then
				if Menu.IsEnabled(Pugna.optionHeroPugnaBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(Pugna.optionHeroPugnaBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(Pugna.optionHeroPugnaBlinkRange))))
					return
				end
			end

			if os.clock() > Pugna.lastTick and not NPC.IsChannellingAbility(myHero) then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					Pugna.lastTick = os.clock() + 0.2
					return
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q) + 300) then
					local pred = 1.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predPos = Pugna.castPrediction(myHero, enemy, pred)
					if not NPC.IsPositionInRange(myHero, predPos, Ability.GetCastRange(Q), 0) then
						local myPos = Entity.GetAbsOrigin(myHero)
						local dist = (myPos - predPos):Length2D()
						local saveCastPos = predPos
						for k = 1, math.floor(dist/25) do
							local searchPos = predPos + (myPos - predPos):Normalized():Scaled(k*25)
							if NPC.IsPositionInRange(myHero, searchPos, Ability.GetCastRange(Q), 0) then
								saveCastPos = searchPos
								break
							end
						end
						if NPC.IsPositionInRange(myHero, saveCastPos, Ability.GetCastRange(Q), 0) then	
							Ability.CastPosition(Q, saveCastPos)
							Pugna.lastTick = os.clock() + 0.2
							return
						end
					else
						Ability.CastPosition(Q, predPos)
						Pugna.lastTick = os.clock() + 0.2
						return
					end

				end

				if Menu.IsEnabled(Pugna.optionHeroPugnaWard) then
					if #Entity.GetHeroesInRadius(myHero, 1200, Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(Pugna.optionHeroPugnaWardCount) then
						if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, 700) then
							Ability.CastPosition(E, Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(100))
							Pugna.lastTick = os.clock() + 0.2
							return
						end
					end
				end

				if Menu.IsEnabled(Pugna.optionHeroPugnaInvis) then
					local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
					local blade = NPC.GetItem(myHero, "item_invis_sword", true)
					local silver = NPC.GetItem(myHero, "item_silver_edge", true)
					if ult and Ability.IsCastable(ult, myMana - 90) and not Pugna.IsHeroInvisible(myHero) then
						if glimmer and Ability.IsCastable(glimmer, myMana) then
							Ability.CastTarget(glimmer, myHero)
							return
						end

						if blade and Ability.IsCastable(blade, myMana) then
							Ability.CastNoTarget(blade)
							return
						end

						if silver and Ability.IsCastable(silver, myMana) then
							Ability.CastNoTarget(silver)
							return
						end
					end
				end

				if ult and Ability.IsCastable(ult, myMana) then
					local castRangeAdjustment = Ability.GetCastRange(ult)
					local dagon = NPC.GetItem(myHero, "item_dagon", true)
						if not dagon then
							for i = 2, 5 do
								dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
								if dagon then 
									break 
								end
							end
						end

						if dagon then
							if Ability.GetCastRange(dagon) < Ability.GetCastRange(ult) then
								castRangeAdjustment = Ability.GetCastRange(dagon)
							end
						end

					if not Ability.IsChannelling(ult) then
						if NPC.IsEntityInRange(myHero, enemy, castRangeAdjustment) then
							Ability.CastTarget(ult, enemy)
							Pugna.lastTick = os.clock() + 0.2
							return
						else
							if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_ATTACK_IMMUNE) then
								Pugna.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
								return
							end
						end	
					end
				end
			end
		end
	end

end

return Pugna
